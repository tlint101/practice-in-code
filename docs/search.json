[
  {
    "objectID": "posts/9-IC50_or_pIC50.html",
    "href": "posts/9-IC50_or_pIC50.html",
    "title": "IC50 or pIC50?",
    "section": "",
    "text": "Sometimes it can feel like science is spoken in an unknowable language. Reading figures you see symbols like √Ö or unit scales for the metric system that make no sense (Does ‚ÄúKangaroos Hop Down Mountains Drinking Chocolate Milk‚Äù even work?!?!?!), especially when starting out. For communicating your work, how the data and the units are represented matters.\nThat brings me back to IC50. I know, I have mentioned it a lot (see here and here). In short, IC50 value indicates if a drug can inhibit a protein activity by 50%. It is an important indicator of how potent a drug may be. However, obtaining the IC50 value can vary in so many ways. The drug potency can also be an indication of what stage the drug is in during development pipeline. The end result makes reporting a given drug‚Äôs potency muddy, especially when trying to compare potency between compounds or compare structures during the development stages.\nThis can be seen when comparing drugs in the dummy table below:\n\n# Dummy Data\ndf\n\n\n\n\n\n\n\n\nDrug\nIC50 (¬µM)\n\n\n\n\n0\nDrug 1\n30.000000\n\n\n1\nDrug 2\n60.000000\n\n\n2\nDrug 3\n0.000345\n\n\n3\nDrug 4\n0.099000\n\n\n4\nDrug 5\n0.800000\n\n\n5\nDrug 6\n0.940000\n\n\n\n\n\n\n\nEw.\nAll reported drugs are in the same units, microMolar (¬µM), but with varying results. Is Drug 1 50% more potent than Drug 2? Are Drug 5 and Drug 6 differ by 0.14 ¬µM. Does that mean they are equally potent? Reporting results in this way has several issues: - A lot of digits! - Difference in 50% implies 50% increase in potency - Implies linear scale\nThe last point is the most important. Rarely are dose-response curves in the linear scale (though it can happen at times). Instead, dose-response curves are more commonly in logarithmic scale. Drugs can have a broad range of concentrations and a logarithmic scale better captures this for plotting. The logarithmic scale also allow curves to be plotted in a nice sigmoidal curve, which can automatically guide our eyes to the all important 50% response value on the curve.\nSo there must be a better way, right?"
  },
  {
    "objectID": "posts/9-IC50_or_pIC50.html#is-ic50-the-only-way",
    "href": "posts/9-IC50_or_pIC50.html#is-ic50-the-only-way",
    "title": "IC50 or pIC50?",
    "section": "",
    "text": "Sometimes it can feel like science is spoken in an unknowable language. Reading figures you see symbols like √Ö or unit scales for the metric system that make no sense (Does ‚ÄúKangaroos Hop Down Mountains Drinking Chocolate Milk‚Äù even work?!?!?!), especially when starting out. For communicating your work, how the data and the units are represented matters.\nThat brings me back to IC50. I know, I have mentioned it a lot (see here and here). In short, IC50 value indicates if a drug can inhibit a protein activity by 50%. It is an important indicator of how potent a drug may be. However, obtaining the IC50 value can vary in so many ways. The drug potency can also be an indication of what stage the drug is in during development pipeline. The end result makes reporting a given drug‚Äôs potency muddy, especially when trying to compare potency between compounds or compare structures during the development stages.\nThis can be seen when comparing drugs in the dummy table below:\n\n# Dummy Data\ndf\n\n\n\n\n\n\n\n\nDrug\nIC50 (¬µM)\n\n\n\n\n0\nDrug 1\n30.000000\n\n\n1\nDrug 2\n60.000000\n\n\n2\nDrug 3\n0.000345\n\n\n3\nDrug 4\n0.099000\n\n\n4\nDrug 5\n0.800000\n\n\n5\nDrug 6\n0.940000\n\n\n\n\n\n\n\nEw.\nAll reported drugs are in the same units, microMolar (¬µM), but with varying results. Is Drug 1 50% more potent than Drug 2? Are Drug 5 and Drug 6 differ by 0.14 ¬µM. Does that mean they are equally potent? Reporting results in this way has several issues: - A lot of digits! - Difference in 50% implies 50% increase in potency - Implies linear scale\nThe last point is the most important. Rarely are dose-response curves in the linear scale (though it can happen at times). Instead, dose-response curves are more commonly in logarithmic scale. Drugs can have a broad range of concentrations and a logarithmic scale better captures this for plotting. The logarithmic scale also allow curves to be plotted in a nice sigmoidal curve, which can automatically guide our eyes to the all important 50% response value on the curve.\nSo there must be a better way, right?"
  },
  {
    "objectID": "posts/9-IC50_or_pIC50.html#pic50---a-scale-that-makes-sense",
    "href": "posts/9-IC50_or_pIC50.html#pic50---a-scale-that-makes-sense",
    "title": "IC50 or pIC50?",
    "section": "pIC50 - A scale That Makes Sense",
    "text": "pIC50 - A scale That Makes Sense\nEnter pIC50. This is essentially the negative log of the IC50 in molar concentration:\n\\[pIC50 = -log_{10}(IC50)\\]\nThis has the advantage of scaling results similar to other logarithmic scales, like the pH scale. This is a handy, because it allows us to quickly gauge a drugs potency. For example:\n\nIC50 of 1 ¬µM is 10-6 M = pIC50 of 6.0\nIC50 of 100 nM is 10-7 M, which is pIC50 = 7.0\nIC50 of 10 nM is 10-8 M, which is pIC50 = 8.0\nIC50 of 1 nM is 10-9 M = pIC50 of 9.0\n\nHey, pIC50 is basically the negative exponent!\nThe pIC50 scales the results in a more reasonable manner. An IC50 of 100 nM is 10-7 is equal to a pIC50 of 7.0. Likewise, an IC50 of 50 nM is 5 x10-8 M, which is also 10-7.3 M, which is pIC50 = 7.3\nAnother way of thinking of the pIC50 scale is comparing it to another logarithmic scale - the pH scale. Remember that between each number, from 3 to 4, it is a difference of 10. So a pH of 3 is ten times more acidic than a pH of 4.\nThis works the same way for pIC50. However, the pIC50 scale has the added benefit of moving in one direction, where the higher number represents greater potency.\nThis can make a big difference in the reporting of a drug. Remember the first table above? We can quickly convert those values into the pIC50 scale.\n\n# Because units are already in ¬µM, must convert log accordingly\ndf['pIC50'] = -np.log10(df['IC50 (¬µM)']* 1e-6).round(2)\ndf\n\n\n\n\n\n\n\n\nDrug\nIC50 (¬µM)\npIC50\n\n\n\n\n0\nDrug 1\n30.000000\n4.52\n\n\n1\nDrug 2\n60.000000\n4.22\n\n\n2\nDrug 3\n0.000345\n9.46\n\n\n3\nDrug 4\n0.099000\n7.00\n\n\n4\nDrug 5\n0.800000\n6.10\n\n\n5\nDrug 6\n0.940000\n6.03\n\n\n\n\n\n\n\nNow that makes the drugs in the table make more sense! The drugs may vary wildly by units, but as pIC50s they are scaled in a manner that can make more intuitive sense. Using the pIC50 of 6.0 (or IC50 of 1,000 nM) as a cutoff, Drug 4, Drug 5, and Drug 6 are the only ones that appear potent. On the pI50 scale, Drug 1 and Drug 2 do not look as appealing."
  },
  {
    "objectID": "posts/9-IC50_or_pIC50.html#a-real-world-example",
    "href": "posts/9-IC50_or_pIC50.html#a-real-world-example",
    "title": "IC50 or pIC50?",
    "section": "A Real-World Example",
    "text": "A Real-World Example\nAnother example of how pIC50 can be used is demoed here through the development of Capivasertib (AZD5363). Capivasertib is an AKT kinase inhibitor recently approved in 2023. It is the 7th approved fragment-derived drug. It was built around a 7-azaindole core and originally started with an IC50 &gt; 100 ¬µM for AKT. That high IC50 is typical starting point for fragment-based drug design. Looking at the first report of Capivasertib, published in 2013, we can list the intermediate compound‚Äôs and their reported IC50. From there we can scale the results to pIC50 and get a better idea of the compounds potency as it moved through the drug optimization stages.\nNOTE I did not follow the optimization linearly - the IC50 varied between compounds, with some more or less potent depending on the moiety substituted and explored. From the paper, we see that the chemists were able to generate many molecules with very high potency, however issues of selectivity were of great concern, leading to a lot of tweaking. A lot of work was put into the development of Capivasertib (not just potency but selectivity!) and should not be dismissed by my simple demo.\n\ndemo_df\n\n\n\n\n\n\n\n\nCompound\nIC50 (¬µM)\npIC50\n\n\n\n\n0\n7-azaindole\n100.000\n4.00\n\n\n1\nCompound 33\n0.276\n6.56\n\n\n2\nCompound 41\n1.313\n5.88\n\n\n3\nCompound 53\n0.030\n7.52\n\n\n4\nCapivasertib\n0.003\n8.52\n\n\n\n\n\n\n\nThe IC50 (¬µM) of the reported intermediates in the published article are, objectively, not good to look at. Especially in Table 3 as the IC50 jumped from 9 nM to almost 2,800 nM depending on the substituent. The above table shows how scaling the IC50 to pIC50 can make the information more intuitive. As the molecule becomes more potent, it will have a higher pIC50 number. Thus, there is a need to forever improve the compound to ‚Äúachieve‚Äù a higher ranking on the pIC50 scale. For Capivarsertib‚Äôs case, it has a pIC50 of 8.52 for AKT1."
  },
  {
    "objectID": "posts/9-IC50_or_pIC50.html#plugs-py50-can-scale-to-pic50",
    "href": "posts/9-IC50_or_pIC50.html#plugs-py50-can-scale-to-pic50",
    "title": "IC50 or pIC50?",
    "section": "üîåPlugs: py50 Can Scale to pIC50!",
    "text": "üîåPlugs: py50 Can Scale to pIC50!\nTo aid in data representation, py50 comes equipped with a function to scale the IC50 into pIC50. This is performed using the calculate_pic50() function. It is built on top of the calculate_absolute_ic50() function. Thus both the relative and absolute pIC50 will be reported. Again, what you report depends on your dataset. Use your best judgement!\nAn example of how this works can be seen below:\n\ncalculation = calc_data.calculate_pic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\n# To keep IC50 columns\ncalculation = calculation[['compound_name', 'relative ic50 (nM)', 'absolute ic50 (nM)', 'relative pIC50', 'absolute pIC50']]\n\ncalculation.round(2)\n\n\n\n\n\n\n\n\ncompound_name\nrelative ic50 (nM)\nabsolute ic50 (nM)\nrelative pIC50\nabsolute pIC50\n\n\n\n\n0\nDrug 1\n429.96\n579.62\n6.37\n6.24\n\n\n1\nDrug 2\n423.05\n660.69\n6.37\n6.18\n\n\n2\nDrug 3\n644.38\n921.71\n6.19\n6.04\n\n\n3\nDrug 4\n398.60\n422.45\n6.40\n6.37\n\n\n\n\n\n\n\nNow when using py50 to calculate IC50 values, anyone can quickly scale their results to pIC50. Hopefully this will bring a more convenient way to represent and display data to classmates, coworkers, advisors, etc.\nFor anyone wanting to look further, the full notebook for this post can be found here. A good post was has been written up by CDD Vault here"
  },
  {
    "objectID": "posts/11-Draw-Molecules-Datamol.html",
    "href": "posts/11-Draw-Molecules-Datamol.html",
    "title": "Drawing Molecules with Datamol",
    "section": "",
    "text": "In the last post I talked about drawing molecules using RDKit. Anyone in cheminformatics knows about RDKit. It is an essential toolkit. But for anyone starting out, it can be frustrating. Think about the basic drawing steps explained in the last post - define the smiles string, convert it into an RDKit molecule (Chem.MolFromSmiles), and then draw the molecule (Draw.MolToImage). That requires three lines of code each time. Trying to find specific tools within RDKit‚Äôs documentation can be a day daunting and frustrating.\nEnter Datamol. This is a toolkit built on top of RDKit. It reduces the molecular drawing steps from three lines of code into one!\nThat makes Datamol is a great tool to start out with. Datamol has a lot of functions ripped right from RDKit and reduces a lot of RDKit‚Äôs bulkiness into one or two lines of code. That makes Datamol perfect for beginners. But this comes with a caveat. Datamol lacks certain features, drawn molecules can be oriented differently compared to RDKit, and Datamol lacks more detailed tools found in RDKit tool. But for most of our needs, like drawing molecules, Datamol makes perfect sense to use.\nHere, we will go over the same drawing skills as the last post. Only this time we use Datamol to draw the molecules."
  },
  {
    "objectID": "posts/11-Draw-Molecules-Datamol.html#intro",
    "href": "posts/11-Draw-Molecules-Datamol.html#intro",
    "title": "Drawing Molecules with Datamol",
    "section": "",
    "text": "In the last post I talked about drawing molecules using RDKit. Anyone in cheminformatics knows about RDKit. It is an essential toolkit. But for anyone starting out, it can be frustrating. Think about the basic drawing steps explained in the last post - define the smiles string, convert it into an RDKit molecule (Chem.MolFromSmiles), and then draw the molecule (Draw.MolToImage). That requires three lines of code each time. Trying to find specific tools within RDKit‚Äôs documentation can be a day daunting and frustrating.\nEnter Datamol. This is a toolkit built on top of RDKit. It reduces the molecular drawing steps from three lines of code into one!\nThat makes Datamol is a great tool to start out with. Datamol has a lot of functions ripped right from RDKit and reduces a lot of RDKit‚Äôs bulkiness into one or two lines of code. That makes Datamol perfect for beginners. But this comes with a caveat. Datamol lacks certain features, drawn molecules can be oriented differently compared to RDKit, and Datamol lacks more detailed tools found in RDKit tool. But for most of our needs, like drawing molecules, Datamol makes perfect sense to use.\nHere, we will go over the same drawing skills as the last post. Only this time we use Datamol to draw the molecules."
  },
  {
    "objectID": "posts/11-Draw-Molecules-Datamol.html#set-up-data",
    "href": "posts/11-Draw-Molecules-Datamol.html#set-up-data",
    "title": "Drawing Molecules with Datamol",
    "section": "Set Up Data",
    "text": "Set Up Data\nAgain, we will focus on 2 molecules - Acetylsalicylic Acid and Ibuprofen. The data is set up as follows:\n\ndata = {'name': ['Acetylsalicylic Acid', 'Ibuprofen'],\n        'smiles': ['O=C(C)Oc1ccccc1C(=O)O', 'CC(C)Cc1ccc(cc1)[C@@H](C)C(=O)O']}\ndf = pd.DataFrame(data=data)\ndf\n\n\n\n\n\n\n\n\nname\nsmiles\n\n\n\n\n0\nAcetylsalicylic Acid\nO=C(C)Oc1ccccc1C(=O)O\n\n\n1\nIbuprofen\nCC(C)Cc1ccc(cc1)[C@@H](C)C(=O)O"
  },
  {
    "objectID": "posts/11-Draw-Molecules-Datamol.html#drawing-the-molecule",
    "href": "posts/11-Draw-Molecules-Datamol.html#drawing-the-molecule",
    "title": "Drawing Molecules with Datamol",
    "section": "Drawing the Molecule",
    "text": "Drawing the Molecule\nLike in the last post, the data is loaded in a DataFrame. It will need to be ‚Äúsliced‚Äù for drawing. In this case, we will use Datamol‚Äôs to_mol() function. This works in one line of code, unlike RDKit which can take two lines.\n\n# Get smiles for 1 molecule smiles string\naspirin = df.iloc[0, 1]\n\n# Draw molecule\nmol = dm.to_mol(aspirin)\nmol\n\n\n\n\nThe above code is technically not a drawing. What it is is a representation of an RDKit molecule. You can try that yourself by using type(mol). You will get ‚Äòrdkit.Chem.rdchem.Mol‚Äô. But the to_mol() is great because the molecule is essentially an RDKit molecule and can be processed using RDKit‚Äôs other functions or functions available in Datamol.\nDrawing a molecule in Datamol is as simple as using to_image() function. Again, this reads more like traditional English syntax. Here we will draw the molecule as an image. To top it off, we will also add a figure legend for the image.\n\n# Input smiles string and figure legend\nmol = dm.to_image(aspirin, legends='Drawing Aspirin with Datamol!', use_svg=False, outfile='img/datamol_example.png', mol_size=(250,250))\nmol\n\n\n\n\n\n# Input smiles string and figure legend\nmol = dm.to_image(aspirin, legends='Aspirin')\nmol\n\n\n\n\nThat looks great! You can also save the image by adding the ‚Äúoutfile‚Äù argument. By default, the image will be in .svg format and if you prefer .png, you should also include ‚ÄúuseSVG=False‚Äù in the parameters too. There are a lot of options and you can dive into them here."
  },
  {
    "objectID": "posts/11-Draw-Molecules-Datamol.html#drawing-molecules-in-a-grid",
    "href": "posts/11-Draw-Molecules-Datamol.html#drawing-molecules-in-a-grid",
    "title": "Drawing Molecules with Datamol",
    "section": "Drawing Molecules in a Grid",
    "text": "Drawing Molecules in a Grid\nThat is all well and good, but what if you want to draw multiple molecules in a grid? Again, that can be accomplished in a single line of code! Even easier, it is done using the same to_image() function!\nThe main thing to keep in mind is that the to_image() function requires the inputs to be in a list. That is easy to do from our DataFrame. Here we will draw the two molecules with their figure legend in a grid by converting their respective columns into a list.\n\n# Convert the smiles column and name columns into a list\nmols = df['smiles'].tolist()\nlegends = df['name'].to_list()\n\n# Draw the molecules!\ndm.to_image(mols=mols, legends=legends, n_cols=2, mol_size=(200,200))\n\n\n\n\nThis is subjective, but I think that code reads a lot smoother, especially if you are a native English speaker. Compare that to the way I drew molecules from a list from the previous post:\nmols = [Chem.MolFromSmiles(mol) for mol in df['smiles']]\nMolsToGridImage(mols, legends=['aspirin', 'Ibuprofen'])\nI am used to it now, but starting out, that read like a whole different langauge to me! Drawing in Datamol makes more sense, especially with their to_image() script."
  },
  {
    "objectID": "posts/11-Draw-Molecules-Datamol.html#additional-tools",
    "href": "posts/11-Draw-Molecules-Datamol.html#additional-tools",
    "title": "Drawing Molecules with Datamol",
    "section": "Additional Tools",
    "text": "Additional Tools\nThese are simple drawing examples. If you dive deeper into their API, you will find that Datamol contains a ton of other useful features. Importantly, they are written in a way that makes a little more sense. Some other things that are important for the cheminformatic toolkit include molecular fingerprints or converting drawn molecules into other 1D formats. Again, Datamol offers a syntax that follows the ‚Äúto_xxx‚Äù format. A lot easier for early coders!\nAt least for the simple things. If you need more rigorous tools, then you‚Äôll have to continue diving into RDKit or other toolkits available."
  },
  {
    "objectID": "posts/11-Draw-Molecules-Datamol.html#conclusion",
    "href": "posts/11-Draw-Molecules-Datamol.html#conclusion",
    "title": "Drawing Molecules with Datamol",
    "section": "Conclusion",
    "text": "Conclusion\nJust know that there are a lot of additional drawing options. If you could not tell, I like drawing images and plan on writing more depending on my schedule. In the meantime, it is good to practice these and thinking about how to add more functionality to it.\nWith RDKit, there are some easy to use tools baked in. You just need to know the right ingredients!\nThe full notebook with the code can be found here."
  },
  {
    "objectID": "posts/8-absolute-ic50.html",
    "href": "posts/8-absolute-ic50.html",
    "title": "py50: Relative or Absolute IC50? ü§î",
    "section": "",
    "text": "I do not know others, but when I first tried calculating IC50, I wanted to pull my teeth out. There is a lot more to know about IC50 than just the calculations and anyone can dive into an endless blackhole of information and never crawl out. Here I will try my best to explain what I know. Plus, it will be good to show off py50 plots. For anyone interested, the main code for this post can be found here.\nTL;DR IC50 can be confusing and the final result will depend on the data you have on hand. Use your best judgement!\n\n\nOn the surface, IC50 is an easy and fundamental pharmacological concept for researchers to quickly gauge the potency of a drug. It essentially asks - ü§î How much of my drug is needed to inhibit my target protein activity by 50%. üí≠ A given drug is tested at different concentrations to achieve this result.\nA good introduction has been written up by Dr.¬†Keith Hornberger (Tweetorial: IC50 vs.¬†Ki). In the article, there are reasons given for why IC50 depends on many factors - the drug being tested, the conditions, which cell, etc. These can all have an influence on the final result.\nGraphically, it will look like a sigmoidal plot (see here), where the Y-axis are the drug responses and the X-axis is the concentration. The concentrations on the X-axis are typically, but not always, logarithmic in order to assess the wide variations in the tested drug concentration. We will see that the final calculated IC50 can be just as ambiguous as the experiment itself. That brings us to Relative vs.¬†Absolute values.\nWhat does Relative vs.¬†Absolute mean? GraphPad has a post explaining this problem: Relative vs.¬†Absolute IC50 and 50% of what? How exactly are Ic50 and EC50 defined?\n\nImage from GraphPad KNOWLEDGEBASE - ARTICLE #1566 (here)\nIn short, Relative IC50 is the concentration that brings the curve down to the point halfway between the top and the bottom plateaus of the curve. This is the most common definition for IC50. When anyone says my drug has an IC50 of X value, it is safe to assume that they mean relative IC50. The problem is that the relative IC50 may not correlate to exactly 50% response (Figure above).\nIn contrast, Absolute IC50 is the value at the exact point where the target response is 50%. The figure above details this point with the horizontal lines. Keep in mind that depending on the dataset and results, the 50% mark can also be ambiguous. It may be best to use absolute IC50 values if the response can be properly converted to a percentage (0% - 100%). However, how this is done can differ between methods and assays.\nIn this tutorial, we will not be too concerted with these aspects. Instead, we will focus on ‚Äúweird‚Äù results that may result from the Relative vs Absolute IC50 calculation. Sometimes these results are due to limited datapoints (i.e.¬†more concentrations should be tested). This will be explained further below.\n\n\n\nFirst we will look at a ‚Äúgood example‚Äù. By this I mean there are enough points that can give a good representation of the plateau at both ends of the response. This is necessary to determine the general curve.\nHere a .csv file will be read as a Pandas DataFrame. The current version of py50 requires a column with the drug name, drug concentration, and response average for the calculations. As seen in the Quickstart tutorial, the ‚Äúcalculate_IC50‚Äù will output a table with the final calculations. By default, the IC50 value is the Relative IC50 value.\n\n# Calculate IC50\nrelative_ic50 = good_example.calculate_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\nrelative_ic50\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nic50 (nM)\nhill_slope\n\n\n\n\n0\nDrug 1\n92.854428\n-7.640263\n439.823988\n1.040875\n\n\n\n\n\n\n\nWe can double check the calculations if we like. There are two online IC50 calculators, AATBioquest IC50 Calculator and the Very Simple IC50 Tool Kit, both of which also give a relative IC50 value of 439.82 nM.\nWhat does that mean graphically? Here, a graph of the dataset will be plotted with a box to highlight the Relative IC50 value. For this we can use the ‚Äúconc_target‚Äù parameter, which will take in the input concentration of interest and draw a box between the X and Y axis with the curve at the intersection. In this case, we will see where the Relative IC50 value (439.82 nM) lands on the curve. This can also be checked using the ‚Äúverbose=True‚Äù argument.\n\n# Instantiate table into PlotCurve class\nabsolute = PlotCurve(good_example_df)\nfigure = absolute.single_curve_plot(concentration_col='Compound Conc',\n                                    response_col='% Inhibition Avg',\n                                    plot_title='Relative IC50 Value',\n                                    drug_name='Drug 1',\n                                    xlabel='Logarithmic Concentration (¬µM)',\n                                    ylabel='Inhibition %',\n                                    conc_unit='¬µM', # Plot the concentration in ¬µM\n                                    box=True,\n                                    box_color='red',\n                                    conc_target=0.43982, # the IC50 value must be in same units as label\n                                    xscale_ticks=(-3, 3), # To extend the tail at both ends of the curve\n                                    figsize=(6.4, 4.8),\n                                    verbose=True)\n\nDrug 1 concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  0.44 ¬µM\nBox Y intersection:  42.607 %\n\n\n\n\n\nNotice that the box is not at the 50% mark on the Y-Axis. Actually it is roughly 42.61% according to the output. Again, we can check this using the AATBioquest IC50 calculator, which also gives an inhibition response of 42.61% for the relative IC50 value. The calculations are consistent with each other. The final result si an IC50 value not exactly at the 50% response mark. Essentially, what is shown is the Relative IC50 value.\n\n\n\nWhat if we are interested to know the concentration at exactly 50% response? This number will be the Absolute IC50 value. We can calculate that easily with the ‚Äúcalculate_absolute_ic50‚Äù function. The exact Absolute IC50 value can also be highlighted using the ‚ÄòBox=True‚Äô parameter and removing the ‚Äòconc_target=‚Äô parameter. By default, the box will be drawn at 50% response.\nBear in mind - Absolute IC50 in this case is relative to the input dataset. Like the relative IC50 value, it can change depending on a number of factors.\nWhen calculating the Absolute IC50 with py50, by default it will output both the Relative and Absolute IC50 values.\nThe Absolute IC50 for this dataset can be calculated and plotted as follows:\n\n# Calculate Absolute IC50\nabsolute_ic50 = good_example.calculate_absolute_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\nabsolute_ic50\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\n\n\n\n\n0\nDrug 1\n92.854428\n-7.640263\n439.823988\n584.734114\n1.040875\n\n\n\n\n\n\n\n\n# Plot Figure\nabsolute = PlotCurve(good_example_df)\nfigure = absolute.single_curve_plot(concentration_col='Compound Conc',\n                                    response_col='% Inhibition Avg',\n                                    plot_title='Absolute IC50 Value',\n                                    drug_name='Drug 1',\n                                    xlabel='Logarithmic Concentration (nM)',\n                                    ylabel='Inhibition %',\n                                    box=True,\n                                    box_color='red',\n                                    conc_unit='¬µM',\n                                    box_intercept=50,\n                                    xscale_ticks=(-3, 3),\n                                    figsize=(6.4, 4.8),\n                                    verbose=True)\n\nDrug 1 concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  0.585 ¬µM\nBox Y intersection:  50 %\n\n\n\n\n\nThe concentration for the Absolute IC50 will be 585.47 nM for this dataset. Again, it can be double checked using the AATBioquest IC50 calculator. When comparing the results on the AATBioquest calculator, the concentration at 50% response on the Y-axis also outputs an X-axis value of 584.72, similar to our calculated Absolute IC50 table.\n\n\n\nThere are a lot of factors that can influence the IC50 calculation. It can also be impacted by the experimental design. The minimum number of concentrations needed to calculate IC50 is two, however there are varying methods that can result in varying numbers. py50, for example, requires at least 4 datapoints to calculate the IC50. And it is always advisable to test at more concentrations than 2 (I personally would be more suspicious if there was only 2 points!). Typically, the more concentrations tested the better and more accurate the calculated IC50 will be.\nHere is another example. In this case, the dummy drug was only tested at five different concentrations.\n\nconfusing_example_df = pd.read_csv('datasets/py50/absolute_example.csv')\nconfusing_example = Calculator(confusing_example_df)\nconfusing_example.show()\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nSay Wha?\n10000\n70\n71\n70\n\n\n1\nSay Wha?\n3000\n61\n59\n60\n\n\n2\nSay Wha?\n1000\n42\n44\n43\n\n\n3\nSay Wha?\n300\n25\n24\n24\n\n\n4\nSay Wha?\n100\n9\n10\n10\n\n\n\n\n\n\n\n\nconfusing_absolute = confusing_example.calculate_absolute_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg') \nconfusing_absolute\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\n\n\n\n\n0\nSay Wha?\n78.113654\n-3.368611\n694.869229\n1498.098675\n0.834368\n\n\n\n\n\n\n\nNotice that with this example, the Relative IC50 and the Absolute IC50 values vary greatly, with the Relative being in the nM and Absolute being in the ¬µM range. A huge difference! Again, similar calculations are seen when using the AATBioquest IC50 calculator. When plotting the results, disheartening results are also shown.\n\ntest = PlotCurve(confusing_example_df)\nfigure = test.single_curve_plot(concentration_col='Compound Conc',\n                                response_col='% Inhibition Avg',\n                                plot_title='Confusing Drug',\n                                drug_name='Say Wha?',\n                                xlabel='Logarithmic Concentration (¬µM)',\n                                ylabel='Inhibition %',\n                                legend=True,\n                                conc_unit='¬µM',\n                                xscale_ticks=(-2.5, 2.5),\n                                line_color='black',\n                                box=True,\n                                box_color='red',\n                                conc_target=0.69487, # Relative IC50 results\n                                figsize = (6.4, 4.8),\n                                verbose=True)\n\nSay Wha? concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  0.695 ¬µM\nBox Y intersection:  37.372 %\n\n\n\n\n\nMore specifically, the Relative IC50 for the Say Wha? is closer to 37.3%. As personal preference, I do not think this is indicative of the meaning for ‚ÄúIC50‚Äù. It is further from the 50% than the first example above! When the plot is adjusted for the Absolute IC50 below, we see a more reasonable graph representation. More specifically, the Absolute IC50 would make more sense in relation to the data as the concentration for 50% inhibition response would be located somewhere between 3000 and 1000 nM (See Table above).\n\nfigure = test.single_curve_plot(concentration_col='Compound Conc',\n                                response_col='% Inhibition Avg',\n                                plot_title='Confusing Drug',\n                                drug_name='Say Wha?',\n                                xlabel='Logarithmic Concentration (¬µM)',\n                                ylabel='Inhibition %',\n                                legend=True,\n                                conc_unit='¬µM',\n                                xscale_ticks=(-2.5, 2.5),\n                                line_color='black',\n                                box=True,\n                                box_color='red',\n                                x_concentration=1.49940,\n                                figsize = (6.4, 4.8),\n                                verbose=True)\n\nSay Wha? concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  1.498 ¬µM\nBox Y intersection:  50 %\n\n\n\n\n\nIn this case, the Absolute IC50 more precisely puts the 50 in IC50. Keep in mind that this only works with the data on hand and for this case, it appears to be a more accurate representation of the dataset.\n\n\n\nOne way to get more precise IC50 calculations is to increase the number of concentrations tested for a given drug. More points, especially at the end of the plateau, would help give a better indication of the drug potency. Here we will add 2 additional concentration points to our test and calculate the Relative and Absolute IC50 Values\n\nnew_conc = [{'Compound Name':'Say Wha?', 'Compound Conc':10, '% Inhibition Avg': 8},\n            {'Compound Name':'Say Wha?', 'Compound Conc':100000, '% Inhibition Avg': 90}]\n\nconfusing_example_df = pd.concat([confusing_example_df, pd.DataFrame(new_conc)], ignore_index=True)\nconfusing_example_df\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nSay Wha?\n10000\n70.0\n71.0\n70\n\n\n1\nSay Wha?\n3000\n61.0\n59.0\n60\n\n\n2\nSay Wha?\n1000\n42.0\n44.0\n43\n\n\n3\nSay Wha?\n300\n25.0\n24.0\n24\n\n\n4\nSay Wha?\n100\n9.0\n10.0\n10\n\n\n5\nSay Wha?\n10\nNaN\nNaN\n8\n\n\n6\nSay Wha?\n100000\nNaN\nNaN\n90\n\n\n\n\n\n\n\n\nexample = Calculator(confusing_example_df)\nexample_ic50 = example.calculate_absolute_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\nexample_ic50\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\n\n\n\n\n0\nSay Wha?\n92.497681\n3.325575\n1563.735262\n1779.972212\n0.723894\n\n\n\n\n\n\n\nFrom the new table, you can see that adding more points will adjust both the Relative and Absolute IC50 values. Both values will begin to move closer to each other. Again, this appears to be reasonable due to the Inhibition average of the dataset, where 50% inhibition should fall somewhere between the 1000 and 3000 nM concentration. This will also change the way the graph looks as follows:\n\nexample_plot = PlotCurve(confusing_example_df)\nfigure = example_plot.single_curve_plot(concentration_col='Compound Conc',\n                                        response_col='% Inhibition Avg',\n                                        plot_title='Confusing Drug with More Data Points',\n                                        drug_name='Say Wha?',\n                                        xlabel='Logarithmic Concentration (¬µM)',\n                                        ylabel='Inhibition %',\n                                        legend=False,\n                                        conc_unit='¬µM',\n                                        xscale_ticks=(-3, 3),\n                                        line_color='black',\n                                        box=True,\n                                        x_concentration=1.563735262, # Highlight Relative IC50 \n                                        box_color='red',\n                                        figsize=(6.4, 4.8),\n                                        verbose=True)\n\nSay Wha? concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  1.78 ¬µM\nBox Y intersection:  50 %\n\n\n\n\n\nUsing the AATBioquest IC50 calculator, if you are feeling adventurous, can be used ot double check the above results. Both the Relative (1563.74 nM) and Absolute IC50 (1782.84 nM) values are closer to the 50% response, with the Relative IC50 increasing to 47.89% response for this example. These results are also reasonable due to the dataset on hand. It may be subjected, but the curve can be smother, and additional testing would be needed to achieve this. Consulting an appropriate protocol would be advisable."
  },
  {
    "objectID": "posts/8-absolute-ic50.html#absolute-ic50",
    "href": "posts/8-absolute-ic50.html#absolute-ic50",
    "title": "py50: Relative or Absolute IC50? ü§î",
    "section": "",
    "text": "I do not know others, but when I first tried calculating IC50, I wanted to pull my teeth out. There is a lot more to know about IC50 than just the calculations and anyone can dive into an endless blackhole of information and never crawl out. Here I will try my best to explain what I know. Plus, it will be good to show off py50 plots. For anyone interested, the main code for this post can be found here.\nTL;DR IC50 can be confusing and the final result will depend on the data you have on hand. Use your best judgement!\n\n\nOn the surface, IC50 is an easy and fundamental pharmacological concept for researchers to quickly gauge the potency of a drug. It essentially asks - ü§î How much of my drug is needed to inhibit my target protein activity by 50%. üí≠ A given drug is tested at different concentrations to achieve this result.\nA good introduction has been written up by Dr.¬†Keith Hornberger (Tweetorial: IC50 vs.¬†Ki). In the article, there are reasons given for why IC50 depends on many factors - the drug being tested, the conditions, which cell, etc. These can all have an influence on the final result.\nGraphically, it will look like a sigmoidal plot (see here), where the Y-axis are the drug responses and the X-axis is the concentration. The concentrations on the X-axis are typically, but not always, logarithmic in order to assess the wide variations in the tested drug concentration. We will see that the final calculated IC50 can be just as ambiguous as the experiment itself. That brings us to Relative vs.¬†Absolute values.\nWhat does Relative vs.¬†Absolute mean? GraphPad has a post explaining this problem: Relative vs.¬†Absolute IC50 and 50% of what? How exactly are Ic50 and EC50 defined?\n\nImage from GraphPad KNOWLEDGEBASE - ARTICLE #1566 (here)\nIn short, Relative IC50 is the concentration that brings the curve down to the point halfway between the top and the bottom plateaus of the curve. This is the most common definition for IC50. When anyone says my drug has an IC50 of X value, it is safe to assume that they mean relative IC50. The problem is that the relative IC50 may not correlate to exactly 50% response (Figure above).\nIn contrast, Absolute IC50 is the value at the exact point where the target response is 50%. The figure above details this point with the horizontal lines. Keep in mind that depending on the dataset and results, the 50% mark can also be ambiguous. It may be best to use absolute IC50 values if the response can be properly converted to a percentage (0% - 100%). However, how this is done can differ between methods and assays.\nIn this tutorial, we will not be too concerted with these aspects. Instead, we will focus on ‚Äúweird‚Äù results that may result from the Relative vs Absolute IC50 calculation. Sometimes these results are due to limited datapoints (i.e.¬†more concentrations should be tested). This will be explained further below.\n\n\n\nFirst we will look at a ‚Äúgood example‚Äù. By this I mean there are enough points that can give a good representation of the plateau at both ends of the response. This is necessary to determine the general curve.\nHere a .csv file will be read as a Pandas DataFrame. The current version of py50 requires a column with the drug name, drug concentration, and response average for the calculations. As seen in the Quickstart tutorial, the ‚Äúcalculate_IC50‚Äù will output a table with the final calculations. By default, the IC50 value is the Relative IC50 value.\n\n# Calculate IC50\nrelative_ic50 = good_example.calculate_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\nrelative_ic50\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nic50 (nM)\nhill_slope\n\n\n\n\n0\nDrug 1\n92.854428\n-7.640263\n439.823988\n1.040875\n\n\n\n\n\n\n\nWe can double check the calculations if we like. There are two online IC50 calculators, AATBioquest IC50 Calculator and the Very Simple IC50 Tool Kit, both of which also give a relative IC50 value of 439.82 nM.\nWhat does that mean graphically? Here, a graph of the dataset will be plotted with a box to highlight the Relative IC50 value. For this we can use the ‚Äúconc_target‚Äù parameter, which will take in the input concentration of interest and draw a box between the X and Y axis with the curve at the intersection. In this case, we will see where the Relative IC50 value (439.82 nM) lands on the curve. This can also be checked using the ‚Äúverbose=True‚Äù argument.\n\n# Instantiate table into PlotCurve class\nabsolute = PlotCurve(good_example_df)\nfigure = absolute.single_curve_plot(concentration_col='Compound Conc',\n                                    response_col='% Inhibition Avg',\n                                    plot_title='Relative IC50 Value',\n                                    drug_name='Drug 1',\n                                    xlabel='Logarithmic Concentration (¬µM)',\n                                    ylabel='Inhibition %',\n                                    conc_unit='¬µM', # Plot the concentration in ¬µM\n                                    box=True,\n                                    box_color='red',\n                                    conc_target=0.43982, # the IC50 value must be in same units as label\n                                    xscale_ticks=(-3, 3), # To extend the tail at both ends of the curve\n                                    figsize=(6.4, 4.8),\n                                    verbose=True)\n\nDrug 1 concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  0.44 ¬µM\nBox Y intersection:  42.607 %\n\n\n\n\n\nNotice that the box is not at the 50% mark on the Y-Axis. Actually it is roughly 42.61% according to the output. Again, we can check this using the AATBioquest IC50 calculator, which also gives an inhibition response of 42.61% for the relative IC50 value. The calculations are consistent with each other. The final result si an IC50 value not exactly at the 50% response mark. Essentially, what is shown is the Relative IC50 value.\n\n\n\nWhat if we are interested to know the concentration at exactly 50% response? This number will be the Absolute IC50 value. We can calculate that easily with the ‚Äúcalculate_absolute_ic50‚Äù function. The exact Absolute IC50 value can also be highlighted using the ‚ÄòBox=True‚Äô parameter and removing the ‚Äòconc_target=‚Äô parameter. By default, the box will be drawn at 50% response.\nBear in mind - Absolute IC50 in this case is relative to the input dataset. Like the relative IC50 value, it can change depending on a number of factors.\nWhen calculating the Absolute IC50 with py50, by default it will output both the Relative and Absolute IC50 values.\nThe Absolute IC50 for this dataset can be calculated and plotted as follows:\n\n# Calculate Absolute IC50\nabsolute_ic50 = good_example.calculate_absolute_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\nabsolute_ic50\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\n\n\n\n\n0\nDrug 1\n92.854428\n-7.640263\n439.823988\n584.734114\n1.040875\n\n\n\n\n\n\n\n\n# Plot Figure\nabsolute = PlotCurve(good_example_df)\nfigure = absolute.single_curve_plot(concentration_col='Compound Conc',\n                                    response_col='% Inhibition Avg',\n                                    plot_title='Absolute IC50 Value',\n                                    drug_name='Drug 1',\n                                    xlabel='Logarithmic Concentration (nM)',\n                                    ylabel='Inhibition %',\n                                    box=True,\n                                    box_color='red',\n                                    conc_unit='¬µM',\n                                    box_intercept=50,\n                                    xscale_ticks=(-3, 3),\n                                    figsize=(6.4, 4.8),\n                                    verbose=True)\n\nDrug 1 concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  0.585 ¬µM\nBox Y intersection:  50 %\n\n\n\n\n\nThe concentration for the Absolute IC50 will be 585.47 nM for this dataset. Again, it can be double checked using the AATBioquest IC50 calculator. When comparing the results on the AATBioquest calculator, the concentration at 50% response on the Y-axis also outputs an X-axis value of 584.72, similar to our calculated Absolute IC50 table.\n\n\n\nThere are a lot of factors that can influence the IC50 calculation. It can also be impacted by the experimental design. The minimum number of concentrations needed to calculate IC50 is two, however there are varying methods that can result in varying numbers. py50, for example, requires at least 4 datapoints to calculate the IC50. And it is always advisable to test at more concentrations than 2 (I personally would be more suspicious if there was only 2 points!). Typically, the more concentrations tested the better and more accurate the calculated IC50 will be.\nHere is another example. In this case, the dummy drug was only tested at five different concentrations.\n\nconfusing_example_df = pd.read_csv('datasets/py50/absolute_example.csv')\nconfusing_example = Calculator(confusing_example_df)\nconfusing_example.show()\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nSay Wha?\n10000\n70\n71\n70\n\n\n1\nSay Wha?\n3000\n61\n59\n60\n\n\n2\nSay Wha?\n1000\n42\n44\n43\n\n\n3\nSay Wha?\n300\n25\n24\n24\n\n\n4\nSay Wha?\n100\n9\n10\n10\n\n\n\n\n\n\n\n\nconfusing_absolute = confusing_example.calculate_absolute_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg') \nconfusing_absolute\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\n\n\n\n\n0\nSay Wha?\n78.113654\n-3.368611\n694.869229\n1498.098675\n0.834368\n\n\n\n\n\n\n\nNotice that with this example, the Relative IC50 and the Absolute IC50 values vary greatly, with the Relative being in the nM and Absolute being in the ¬µM range. A huge difference! Again, similar calculations are seen when using the AATBioquest IC50 calculator. When plotting the results, disheartening results are also shown.\n\ntest = PlotCurve(confusing_example_df)\nfigure = test.single_curve_plot(concentration_col='Compound Conc',\n                                response_col='% Inhibition Avg',\n                                plot_title='Confusing Drug',\n                                drug_name='Say Wha?',\n                                xlabel='Logarithmic Concentration (¬µM)',\n                                ylabel='Inhibition %',\n                                legend=True,\n                                conc_unit='¬µM',\n                                xscale_ticks=(-2.5, 2.5),\n                                line_color='black',\n                                box=True,\n                                box_color='red',\n                                conc_target=0.69487, # Relative IC50 results\n                                figsize = (6.4, 4.8),\n                                verbose=True)\n\nSay Wha? concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  0.695 ¬µM\nBox Y intersection:  37.372 %\n\n\n\n\n\nMore specifically, the Relative IC50 for the Say Wha? is closer to 37.3%. As personal preference, I do not think this is indicative of the meaning for ‚ÄúIC50‚Äù. It is further from the 50% than the first example above! When the plot is adjusted for the Absolute IC50 below, we see a more reasonable graph representation. More specifically, the Absolute IC50 would make more sense in relation to the data as the concentration for 50% inhibition response would be located somewhere between 3000 and 1000 nM (See Table above).\n\nfigure = test.single_curve_plot(concentration_col='Compound Conc',\n                                response_col='% Inhibition Avg',\n                                plot_title='Confusing Drug',\n                                drug_name='Say Wha?',\n                                xlabel='Logarithmic Concentration (¬µM)',\n                                ylabel='Inhibition %',\n                                legend=True,\n                                conc_unit='¬µM',\n                                xscale_ticks=(-2.5, 2.5),\n                                line_color='black',\n                                box=True,\n                                box_color='red',\n                                x_concentration=1.49940,\n                                figsize = (6.4, 4.8),\n                                verbose=True)\n\nSay Wha? concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  1.498 ¬µM\nBox Y intersection:  50 %\n\n\n\n\n\nIn this case, the Absolute IC50 more precisely puts the 50 in IC50. Keep in mind that this only works with the data on hand and for this case, it appears to be a more accurate representation of the dataset.\n\n\n\nOne way to get more precise IC50 calculations is to increase the number of concentrations tested for a given drug. More points, especially at the end of the plateau, would help give a better indication of the drug potency. Here we will add 2 additional concentration points to our test and calculate the Relative and Absolute IC50 Values\n\nnew_conc = [{'Compound Name':'Say Wha?', 'Compound Conc':10, '% Inhibition Avg': 8},\n            {'Compound Name':'Say Wha?', 'Compound Conc':100000, '% Inhibition Avg': 90}]\n\nconfusing_example_df = pd.concat([confusing_example_df, pd.DataFrame(new_conc)], ignore_index=True)\nconfusing_example_df\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nSay Wha?\n10000\n70.0\n71.0\n70\n\n\n1\nSay Wha?\n3000\n61.0\n59.0\n60\n\n\n2\nSay Wha?\n1000\n42.0\n44.0\n43\n\n\n3\nSay Wha?\n300\n25.0\n24.0\n24\n\n\n4\nSay Wha?\n100\n9.0\n10.0\n10\n\n\n5\nSay Wha?\n10\nNaN\nNaN\n8\n\n\n6\nSay Wha?\n100000\nNaN\nNaN\n90\n\n\n\n\n\n\n\n\nexample = Calculator(confusing_example_df)\nexample_ic50 = example.calculate_absolute_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\nexample_ic50\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\n\n\n\n\n0\nSay Wha?\n92.497681\n3.325575\n1563.735262\n1779.972212\n0.723894\n\n\n\n\n\n\n\nFrom the new table, you can see that adding more points will adjust both the Relative and Absolute IC50 values. Both values will begin to move closer to each other. Again, this appears to be reasonable due to the Inhibition average of the dataset, where 50% inhibition should fall somewhere between the 1000 and 3000 nM concentration. This will also change the way the graph looks as follows:\n\nexample_plot = PlotCurve(confusing_example_df)\nfigure = example_plot.single_curve_plot(concentration_col='Compound Conc',\n                                        response_col='% Inhibition Avg',\n                                        plot_title='Confusing Drug with More Data Points',\n                                        drug_name='Say Wha?',\n                                        xlabel='Logarithmic Concentration (¬µM)',\n                                        ylabel='Inhibition %',\n                                        legend=False,\n                                        conc_unit='¬µM',\n                                        xscale_ticks=(-3, 3),\n                                        line_color='black',\n                                        box=True,\n                                        x_concentration=1.563735262, # Highlight Relative IC50 \n                                        box_color='red',\n                                        figsize=(6.4, 4.8),\n                                        verbose=True)\n\nSay Wha? concentration will be in ¬µM!\nConcentration on X-axis will be in ¬µM\nBox X intersection:  1.78 ¬µM\nBox Y intersection:  50 %\n\n\n\n\n\nUsing the AATBioquest IC50 calculator, if you are feeling adventurous, can be used ot double check the above results. Both the Relative (1563.74 nM) and Absolute IC50 (1782.84 nM) values are closer to the 50% response, with the Relative IC50 increasing to 47.89% response for this example. These results are also reasonable due to the dataset on hand. It may be subjected, but the curve can be smother, and additional testing would be needed to achieve this. Consulting an appropriate protocol would be advisable."
  },
  {
    "objectID": "posts/13-Announcing-pharmacophore-toolkit.html",
    "href": "posts/13-Announcing-pharmacophore-toolkit.html",
    "title": "Announcing the pharmacophore-toolkit!",
    "section": "",
    "text": "For the past year, I have been absent from this space. That doesn‚Äôt mean I haven‚Äôt been busy! Lately my interests have shifted to making apps targeting cheminformatics and drug discovery. My target audience is my lab members, but I have also released the tools for the wider public. One that I am happy to have recently created is the pharmacophore-toolkit.\n\n\nThere are plenty of tools available to model Structure-Activity Relationship (SAR). Famous software suites include Cresset Flare or Schr√∂dinger Maestro (video tutorial here). I particularly like Flare for their Activity Miner tool. Schr√∂dinger has a great docking module, but is also equipped with additional computational tools that support molecular designs. The aforementioned programs, and other computational pieces of software that support drug design, are great in their own right.\nNonetheless, many of these tools require a subscription. Depending on your goals, paying for a subscription and not utilizing all of the tools can be a downer. Some software suites may offer an academic license, but with a severe lock on the ‚Äúfancier‚Äù tools. Luckily, there are plenty of open source tools that you can combine, along with some elbow grease, to create a tool that works in a similar way.\nThus, pharmacophore-toolkit was born. I wanted to make a script that is, hopefully, easy to use and can generate informative images for analysis and communication between lab groups.\nThe below is a short demo adapted from the pharmacophore-toolkit tutorial here.\n\n\n\n\n\nIn this project, we will import rdkit and the pharmacophore-toolkit (pharmacophore) and their associated modules.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem, rdMolAlign\nfrom rdkit.Chem.Draw import MolsToGridImage\nfrom pharmacophore import Pharmacophore, Draw, View\n\n\n\n\nThe example compounds include three molecules that binds to the serotonin receptor 5HT-2A. This protein belongs to the larger GPCR family of proteins and is famous for having a central role in psychedelic drugs such as LSD and psylocibin mushrooms. Fun stuff! The three molecules in this example will include serotonin (duh!), psilocin (üçÑ), and mescaline(üåµ).\n\nmolecules = {\"serotonin\": \"C1=CC2=C(C=C1O)C(=CN2)CCN\",\n             \"psilocin\": \"CN(C)CCc1c[nH]c2cccc(O)c12\",\n             \"mescaline\": \"O(c1cc(cc(OC)c1OC)CCN)C\"}\n\nmol_smi = [x for x in molecules.values()]\nmol_name = [x for x in molecules.keys()]\nmols = [Chem.MolFromSmiles(x) for x in mol_smi]\n\nMolsToGridImage(mols=mols, legends=mol_name)\n\n\n\n\n\n\n\nFor effective pharmacophore modeling, the molecules need to be rendered with their 3D conformation. This can come from a variety of ways. To keep things simple, the 3D conformation of the molecules in this demo will be generated using RDKit.\n\n# generating 3D conformation\nmols = [Chem.AddHs(m) for m in mols]\nps = AllChem.ETKDGv3()\nps.randomSeed = 42\nfor m in mols:\n    AllChem.EmbedMolecule(m,ps)\n\n# aligning the molecules\naligned = []\nfor x in mols:\n    mol_aligned = rdMolAlign.GetO3A(x,mols[0])\n    aligned.append(mol_aligned.Align())\n\nThe molecules should now be drawn with 3D coordinates. This can be visualized by drawing the molecules. Notice that the molecules are drawn differently on a 2D plane.\n\nmols_noH = [Chem.RemoveHs(m) for m in mols]  # remove hydrogens for clarity.\n\nMolsToGridImage(mols=mols_noH, legends=mol_name)\n\n\n\n\n\n\n\nThere are three ways to generate pharmacophores - an interactive 3D widget using py3Dmol, as a .xyz file for use in PyMOL, and as a 2D image as a .png file.\n\n\nFirst, the pharmacophore features will need to be generated. As of this version, only one pharmacophore can be generated at a time. In this example, pharmacophores for the first molecule, serotonin, will be generated. this will produce a list of lists, with each list containing the pharmacophore label, its atom position, and XYZ coordinates. Once calculated, this data will be used to render the pharmacophores for the images.\n\n# default\npharm = Pharmacophore()\npharma = pharm.calc_pharm(mols_noH[0])\npharma\n\n[['Donor', (9,), -0.9046174520168838, -2.235699615827842, 0.13645934200480056],\n ['Donor', (12,), 2.949925200279259, -0.15648413497184238, 1.2254205073233995],\n ['Donor', (6,), -2.5995394084260526, 2.931207478597561, -0.5905278269049035],\n ['Aromatic',\n  (0, 1, 2, 3, 4, 5),\n  -1.8583650464904398,\n  0.2926900071440297,\n  -0.1871054571985934],\n ['Aromatic',\n  (2, 3, 7, 8, 9),\n  -0.384216675975982,\n  -1.2654866328983938,\n  -0.21240652662909393]]\n\n\n\n\n\nThe pharmacophores generated above are now ready to be used for generating pharmacophores. Each pharmacophore is represented as a sphere with the centroid located on the atom. Currently, the pharmacophores were only generated once for the first molecule. So while the view() method contains a dropdown menu to select from list of molecules, the drawn pharmacophores will only correspond to the pharmacophore list generated from the code block above. In this case, serotonin.\n\nv = View()\nv.view(mols_noH, pharma, labels=True, window=(500, 500))\n\n\n\n\n\nNOTE: This code block generates an interactive window and is intended for use in Jupyter Notebooks only. It cannot be rendered for this blog post (static webpage). Instead, an image of the window is included.\nThe view() method can also handle a list of pharmacophores. This has the benefit of changing the pharmacophore spheres with each rendered molecule. This is done by generating multiple pharmacophores and including the results ina list. An example of this is as follows:\n\npharma = []\nfor x in mols_noH:\n    calc = pharm.calc_pharm(x)\n    pharma.append(calc)\n\n\n\n\nThe pharmacophores-toolkit can generate a .xyz file to be used with PyMOL. This contains information for the pharmacophores - 3D coordinates, sphere color, sphere size, etc. Once this is generated, users can drag and drop this file into their PyMOL application to render the pharmacophore with their molecule. The resulting images should generate pharmacophore spheres superimposed on the molecule. The output will give a message describing the number of pharmacophore features generated.\n\npharm.output_features(savepath='pharma.pml')\n\nNumber of features: 8\nFeature visualization script written to pharma.pml.\n\n\nIn this case, the pharmacophore features for the last item in the list is generated. This should correspond with mescalin.\n\nNOTE: A sample image of what this would look like in pymol is given here. Like the interactive module above, the pharmacophores will need to be rendered for each molecule separately. In this example, the pharmacophores for serotonin were generated. The psilocin and mescaline molecules were drawn with the serotonin pharmacophore spheres to highlight their structural differences.\n\n\n\nFinally, a 2D image can be generated with spheres highlighting the pharmacophores. Images were drawn using RDKit and colored by their respective pharmacophores.\n\ndraw = Draw()\ndraw.draw_pharm(mols_noH[0])"
  },
  {
    "objectID": "posts/13-Announcing-pharmacophore-toolkit.html#motivation",
    "href": "posts/13-Announcing-pharmacophore-toolkit.html#motivation",
    "title": "Announcing the pharmacophore-toolkit!",
    "section": "",
    "text": "There are plenty of tools available to model Structure-Activity Relationship (SAR). Famous software suites include Cresset Flare or Schr√∂dinger Maestro (video tutorial here). I particularly like Flare for their Activity Miner tool. Schr√∂dinger has a great docking module, but is also equipped with additional computational tools that support molecular designs. The aforementioned programs, and other computational pieces of software that support drug design, are great in their own right.\nNonetheless, many of these tools require a subscription. Depending on your goals, paying for a subscription and not utilizing all of the tools can be a downer. Some software suites may offer an academic license, but with a severe lock on the ‚Äúfancier‚Äù tools. Luckily, there are plenty of open source tools that you can combine, along with some elbow grease, to create a tool that works in a similar way.\nThus, pharmacophore-toolkit was born. I wanted to make a script that is, hopefully, easy to use and can generate informative images for analysis and communication between lab groups.\nThe below is a short demo adapted from the pharmacophore-toolkit tutorial here."
  },
  {
    "objectID": "posts/13-Announcing-pharmacophore-toolkit.html#demo",
    "href": "posts/13-Announcing-pharmacophore-toolkit.html#demo",
    "title": "Announcing the pharmacophore-toolkit!",
    "section": "",
    "text": "In this project, we will import rdkit and the pharmacophore-toolkit (pharmacophore) and their associated modules.\n\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem, rdMolAlign\nfrom rdkit.Chem.Draw import MolsToGridImage\nfrom pharmacophore import Pharmacophore, Draw, View\n\n\n\n\nThe example compounds include three molecules that binds to the serotonin receptor 5HT-2A. This protein belongs to the larger GPCR family of proteins and is famous for having a central role in psychedelic drugs such as LSD and psylocibin mushrooms. Fun stuff! The three molecules in this example will include serotonin (duh!), psilocin (üçÑ), and mescaline(üåµ).\n\nmolecules = {\"serotonin\": \"C1=CC2=C(C=C1O)C(=CN2)CCN\",\n             \"psilocin\": \"CN(C)CCc1c[nH]c2cccc(O)c12\",\n             \"mescaline\": \"O(c1cc(cc(OC)c1OC)CCN)C\"}\n\nmol_smi = [x for x in molecules.values()]\nmol_name = [x for x in molecules.keys()]\nmols = [Chem.MolFromSmiles(x) for x in mol_smi]\n\nMolsToGridImage(mols=mols, legends=mol_name)\n\n\n\n\n\n\n\nFor effective pharmacophore modeling, the molecules need to be rendered with their 3D conformation. This can come from a variety of ways. To keep things simple, the 3D conformation of the molecules in this demo will be generated using RDKit.\n\n# generating 3D conformation\nmols = [Chem.AddHs(m) for m in mols]\nps = AllChem.ETKDGv3()\nps.randomSeed = 42\nfor m in mols:\n    AllChem.EmbedMolecule(m,ps)\n\n# aligning the molecules\naligned = []\nfor x in mols:\n    mol_aligned = rdMolAlign.GetO3A(x,mols[0])\n    aligned.append(mol_aligned.Align())\n\nThe molecules should now be drawn with 3D coordinates. This can be visualized by drawing the molecules. Notice that the molecules are drawn differently on a 2D plane.\n\nmols_noH = [Chem.RemoveHs(m) for m in mols]  # remove hydrogens for clarity.\n\nMolsToGridImage(mols=mols_noH, legends=mol_name)\n\n\n\n\n\n\n\nThere are three ways to generate pharmacophores - an interactive 3D widget using py3Dmol, as a .xyz file for use in PyMOL, and as a 2D image as a .png file.\n\n\nFirst, the pharmacophore features will need to be generated. As of this version, only one pharmacophore can be generated at a time. In this example, pharmacophores for the first molecule, serotonin, will be generated. this will produce a list of lists, with each list containing the pharmacophore label, its atom position, and XYZ coordinates. Once calculated, this data will be used to render the pharmacophores for the images.\n\n# default\npharm = Pharmacophore()\npharma = pharm.calc_pharm(mols_noH[0])\npharma\n\n[['Donor', (9,), -0.9046174520168838, -2.235699615827842, 0.13645934200480056],\n ['Donor', (12,), 2.949925200279259, -0.15648413497184238, 1.2254205073233995],\n ['Donor', (6,), -2.5995394084260526, 2.931207478597561, -0.5905278269049035],\n ['Aromatic',\n  (0, 1, 2, 3, 4, 5),\n  -1.8583650464904398,\n  0.2926900071440297,\n  -0.1871054571985934],\n ['Aromatic',\n  (2, 3, 7, 8, 9),\n  -0.384216675975982,\n  -1.2654866328983938,\n  -0.21240652662909393]]\n\n\n\n\n\nThe pharmacophores generated above are now ready to be used for generating pharmacophores. Each pharmacophore is represented as a sphere with the centroid located on the atom. Currently, the pharmacophores were only generated once for the first molecule. So while the view() method contains a dropdown menu to select from list of molecules, the drawn pharmacophores will only correspond to the pharmacophore list generated from the code block above. In this case, serotonin.\n\nv = View()\nv.view(mols_noH, pharma, labels=True, window=(500, 500))\n\n\n\n\n\nNOTE: This code block generates an interactive window and is intended for use in Jupyter Notebooks only. It cannot be rendered for this blog post (static webpage). Instead, an image of the window is included.\nThe view() method can also handle a list of pharmacophores. This has the benefit of changing the pharmacophore spheres with each rendered molecule. This is done by generating multiple pharmacophores and including the results ina list. An example of this is as follows:\n\npharma = []\nfor x in mols_noH:\n    calc = pharm.calc_pharm(x)\n    pharma.append(calc)\n\n\n\n\nThe pharmacophores-toolkit can generate a .xyz file to be used with PyMOL. This contains information for the pharmacophores - 3D coordinates, sphere color, sphere size, etc. Once this is generated, users can drag and drop this file into their PyMOL application to render the pharmacophore with their molecule. The resulting images should generate pharmacophore spheres superimposed on the molecule. The output will give a message describing the number of pharmacophore features generated.\n\npharm.output_features(savepath='pharma.pml')\n\nNumber of features: 8\nFeature visualization script written to pharma.pml.\n\n\nIn this case, the pharmacophore features for the last item in the list is generated. This should correspond with mescalin.\n\nNOTE: A sample image of what this would look like in pymol is given here. Like the interactive module above, the pharmacophores will need to be rendered for each molecule separately. In this example, the pharmacophores for serotonin were generated. The psilocin and mescaline molecules were drawn with the serotonin pharmacophore spheres to highlight their structural differences.\n\n\n\nFinally, a 2D image can be generated with spheres highlighting the pharmacophores. Images were drawn using RDKit and colored by their respective pharmacophores.\n\ndraw = Draw()\ndraw.draw_pharm(mols_noH[0])"
  },
  {
    "objectID": "posts/10-Draw-Molecules.html",
    "href": "posts/10-Draw-Molecules.html",
    "title": "Drawing Molecules",
    "section": "",
    "text": "When I was learning to code, I found it frustrating. My journey took me across different languages by what I wanted to do and by recommendations by others. I found it easy to follow tutorials, but when I tried my own things, nothing ever worked. I stopped and started at least three times and I could never finish anything. It took a while, but I realized what the problem was - I needed to find my own project. As a student in cheminformatics, I was lucky that I have plenty of topics to choose from that will allow me to get better. It helps that, at their core, the topics all use similar toolsets.\nBut how does anyone start? Nothing complicated for sure. I started small and added complexity.\nWhat better way to start than by learning how to draw molecules? It may sound dumb, but this is one of the most important tools to have in your pocket. Drawing one molecule in a graphical GUI program is easy. Drawing 10? 30? 50? Now that is just torture. Don‚Äôt do that to yourself!\nSo today I wanted to go over a basic skill - drawing molecules using RDKit."
  },
  {
    "objectID": "posts/10-Draw-Molecules.html#starting-small",
    "href": "posts/10-Draw-Molecules.html#starting-small",
    "title": "Drawing Molecules",
    "section": "",
    "text": "When I was learning to code, I found it frustrating. My journey took me across different languages by what I wanted to do and by recommendations by others. I found it easy to follow tutorials, but when I tried my own things, nothing ever worked. I stopped and started at least three times and I could never finish anything. It took a while, but I realized what the problem was - I needed to find my own project. As a student in cheminformatics, I was lucky that I have plenty of topics to choose from that will allow me to get better. It helps that, at their core, the topics all use similar toolsets.\nBut how does anyone start? Nothing complicated for sure. I started small and added complexity.\nWhat better way to start than by learning how to draw molecules? It may sound dumb, but this is one of the most important tools to have in your pocket. Drawing one molecule in a graphical GUI program is easy. Drawing 10? 30? 50? Now that is just torture. Don‚Äôt do that to yourself!\nSo today I wanted to go over a basic skill - drawing molecules using RDKit."
  },
  {
    "objectID": "posts/10-Draw-Molecules.html#set-up-data",
    "href": "posts/10-Draw-Molecules.html#set-up-data",
    "title": "Drawing Molecules",
    "section": "Set Up Data",
    "text": "Set Up Data\nIn this quick tutorial, we will draw 2 molecules. We‚Äôll start small and get more complicated. I want to focus on drawing molecular structures for two drugs many of us may know - Acetylsalicylic Acid and Ibuprofen. Or for anyone well verse with the American market, aspirin and advil, respectively. The data is set up as follows:\n\nimport pandas as pd\nfrom rdkit import Chem\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import MolsToGridImage\n\ndata = {'name': ['Acetylsalicylic Acid', 'Ibuprofen'],\n        'smiles': ['O=C(C)Oc1ccccc1C(=O)O', 'CC(C)Cc1ccc(cc1)[C@@H](C)C(=O)O']}\ndf = pd.DataFrame(data=data)\ndf\n\n\n\n\n\n\n\n\nname\nsmiles\n\n\n\n\n0\nAcetylsalicylic Acid\nO=C(C)Oc1ccccc1C(=O)O\n\n\n1\nIbuprofen\nCC(C)Cc1ccc(cc1)[C@@H](C)C(=O)O"
  },
  {
    "objectID": "posts/10-Draw-Molecules.html#drawing-the-molecule",
    "href": "posts/10-Draw-Molecules.html#drawing-the-molecule",
    "title": "Drawing Molecules",
    "section": "Drawing the Molecule",
    "text": "Drawing the Molecule\nBecause I loaded up my dataset as a DataFrame, I will need to ‚Äúslice‚Äù the table into a format for drawing. In this case, the important information is the smiles string. My brain works in Tables, but if you prefer, you can write out the smiles string directly for drawing the molecule, i.e.¬†aspirin = ‚ÄòO=C(C)Oc1ccccc1C(=O)O‚Äô\nNext, the smiles string will need to be converted an rdkit molecule object. This is done using MolFromSmiles() function.\n\naspirin = df.iloc[0, 1]\nmol = Chem.MolFromSmiles(aspirin)\nimg = Draw.MolToImage(mol)\nimg\n\n\n\n\nNOTE If you print out the type of the img object, you will see that it is a PIL object. As such, it can be manipulated using the PIL Image module. I do not have much experience with that as I am normally quite happy with the default outcomes.\nprint(type(image))\nAnother cool feature is that you can add a legend to the individual images. In this case we can test it out for aspirin.\n\nimg = Draw.MolToImage(mol, legend='aspirin')\nimg\n\n\n\n\nDrawing a single molecule is all well and good, but what if we wanted to draw multiple molecules? The good news is that RDKit allows this with a MolsToGridImage() function.\nTo use this, pass a list of RDKit objects into function for drawing."
  },
  {
    "objectID": "posts/10-Draw-Molecules.html#drawing-molecules-in-a-grid",
    "href": "posts/10-Draw-Molecules.html#drawing-molecules-in-a-grid",
    "title": "Drawing Molecules",
    "section": "Drawing Molecules in a Grid",
    "text": "Drawing Molecules in a Grid\nThose examples above are for single compounds. It is a great tool and, when we grasp more complex script, we can quickly draw multiple molecules by looping through a list of smiles strings. That is great, but depending on our aims, individual drawings might not cut it. Enter a neat tool by RDKit - drawing molecules in a grid!\nIt is as simple as drawing the individual molecules. All that is needed is a list of smiles strings. Like the previous example, more extra information can be added to the image. Here I kept it simple and passed a list of molecule names.\n\nmols = [Chem.MolFromSmiles(mol) for mol in df['smiles']]\nMolsToGridImage(mols, legends=['aspirin', 'Ibuprofen'])"
  },
  {
    "objectID": "posts/10-Draw-Molecules.html#conclusion",
    "href": "posts/10-Draw-Molecules.html#conclusion",
    "title": "Drawing Molecules",
    "section": "Conclusion",
    "text": "Conclusion\nJust know that there are a lot of additional drawing options. If you could not tell, I like drawing images and plan on writing more depending on my schedule. In the meantime, it is good to practice these and thinking about how to add more functionality to it.\nWith RDKit, there are some easy to use tools baked in. You just need to know the right ingredients!\nThe full notebook with the code can be found here."
  },
  {
    "objectID": "posts/7-py50-additional-features.html",
    "href": "posts/7-py50-additional-features.html",
    "title": "py50 - Showing off Color Features",
    "section": "",
    "text": "Last post I gave a quick rundown of py50. Here I would like to explain additional features, mainly color and highlighting options.\nWhen it comes to figures, I think they are one of the more difficult aspects of writing a paper. A good figure must be many things. It must not only convey to the audience what was done, but also the outcome and our own interpretation said results. The figures are also a chance to add a bit of pizazz to the manuscript or presentation. There is nothing wrong with the classic black and white figures, but they can come across as stilted and boring, especially now in 2024 were many manuscripts are downloaded and read as PDFs. Adding additional flourishes to highlight our points with a dash of color will allow our personality, and by extension the research we are trying to convey, to shine.\npy50 offers some of these functions that will, hopefully, allow the figures and results to pop. While py50 offers three different plotting styles, the colors and highlighting options stay the same across the functions. I will show a few examples across all three plot styles.\nFor those who want to get their hands dirty immediately, the functions are explained in more detail at the documentation page"
  },
  {
    "objectID": "posts/7-py50-additional-features.html#example-with-single-plot",
    "href": "posts/7-py50-additional-features.html#example-with-single-plot",
    "title": "py50 - Showing off Color Features",
    "section": "Example with Single Plot",
    "text": "Example with Single Plot\nIn addition to the typical configurations for a plot shown here - Plot Title and axis labels - the curve color can be adjusted. This takes the standard name of the color names (red, green, blue, etc) or hex codes. Further, users can highlight IC50 values on the curve using the ‚Äòbox=True‚Äô argument. By default, the box will be gray. Again, the box color can be adjusted using the color names or hex codes. Importantly, the box does not need to correspond with the IC50. If you wanted to highlight a different area, say IC60, the box can be adjusted accordingly using the ‚Äòbox_intercept‚Äô argument.\nAll information associated with the plots can be generated using the verbose=True argument. This will print out information related to the plot, consisting of what drug concentration py50 assumes the data is in, what concentration the X-axis will be in (default is in nM), and the concentration and response for the box.\n\ndf = pd.read_csv('datasets/py50/single_example.csv')\ndata = PlotCurve(df)\n\nfigure = data.single_curve_plot(drug_name='Drug 1',\n                                concentration_col='Compound Conc',\n                                response_col='% Inhibition Avg',\n                                plot_title='Modified Single Curve',\n                                xlabel='Concentration in nM',\n                                ylabel='Response %',\n                                line_color='teal',\n                                box=True,\n                                box_color='#E0115F',\n                                box_intercept=60,\n                                verbose=True)\n\nDrug 1 concentration will be in nM!\nConcentration on X-axis will be in nM\nBox X intersection:  880.204 nM\nBox Y intersection:  60 %\n\n\n\n\n\nFor those who do not like the box but still want to highlight a particular value on the curve, there are ‚Äòvline‚Äô or ‚Äòhline‚Äô arguments. This will draw a dash line across the length of the plot. It is valid for both vertical and horizontal directions.\n\nfigure = data.single_curve_plot(drug_name='Drug 1',\n                                concentration_col='Compound Conc',\n                                response_col='% Inhibition Avg',\n                                plot_title='Modified Single Curve in Hulk Colors',\n                                xlabel='Concentration in nM',\n                                ylabel='Response %',\n                                line_color='green',\n                                hline=50,\n                                hline_color='purple')"
  },
  {
    "objectID": "posts/7-py50-additional-features.html#example-with-multiple-curves",
    "href": "posts/7-py50-additional-features.html#example-with-multiple-curves",
    "title": "py50 - Showing off Color Features",
    "section": "Example with Multiple Curves",
    "text": "Example with Multiple Curves\nDepending on the situation, it may be more prudent to show multiple curves in a single plot. That can be done using the multi_curve_plot() function. Again, the options shown here are available in all three plots. By default, the multi_curve_plot() uses a colorblind color and marker palette, but custom colors and markers can be passed as a list.\n\ndf = pd.read_csv('datasets/py50/multiple_example.csv')\ndata = PlotCurve(df)\n\nrainbow = ['#ff0000', '#ffa500', '#008000', '#ee82ee']\n\nfigure = data.multi_curve_plot(name_col='Compound Name',\n                               concentration_col='Compound Conc',\n                               response_col='% Inhibition Avg',\n                               plot_title='Multi-Curves in Rainbow',\n                               xlabel='Concentration (nM)',\n                               ylabel='Response',\n                               legend=True,\n                               line_color=rainbow)\n\n\n\n\nNotice that some points above are below the 0% response. Depending on your dataset, these may be outliers. These can be shown by adjusting the Y axis using either the ymax or ymin arguments.\nWith multiple lines in the plot, it may be more prudent to highlight the response. The box can be drawn, but can only be drawn for a specific drug. In this case, the vline or hline arguments would serve better. Here a specific concentration is highlighted instead. The units for the vline must correspond to the plot units. In this case, the vline will be in nanomolar (nM) concentration. Colors can also be specified using the vline_color or hline_color, repsectively.\nThis example uses the vline at 880.2 nM, which roughly translates to the IC50 value for Drug 3.\n\nfigure = data.multi_curve_plot(name_col='Compound Name',\n                               concentration_col='Compound Conc',\n                               response_col='% Inhibition Avg',\n                               plot_title='Multi-Curves in Rainbow',\n                               xlabel='Concentration (nM)',\n                               ylabel='Response',\n                               legend=True,\n                               line_color=rainbow,\n                               ymin=-10,\n                               vline=880.2,\n                               vline_color='blue')"
  },
  {
    "objectID": "posts/7-py50-additional-features.html#example-with-grid-plots",
    "href": "posts/7-py50-additional-features.html#example-with-grid-plots",
    "title": "py50 - Showing off Color Features",
    "section": "Example with Grid Plots",
    "text": "Example with Grid Plots\nFinally, multiple curves can be plotted and arrayed in a grid. Importantly, the grid_curve_plot() function contains an additional argument - column_num. This argument will format the curves accordingly. Note the number of curves must be even if you want to array the curves in a grid format. For now, the example will utilize four graphs.\nBy default, the grid curves are arrayed in a color-blind palette. They can be changed by inputting a color in a list format.\nWe can reposition how the plots are laid out using the ‚Äúcolumn_num=‚Äù argument. Note that if this argument is called, the figures will be ‚Äúdistroted‚Äù. The subplots can be adjusted by including the ‚Äúfigsize=‚Äù argument and adjusting the size accordingly.\nBy default, the grid_curve_plot() was figure size is adjusted for two cures. As a result, the figsize is adjusted manually in these examples.\n\nfigure = data.grid_curve_plot(name_col='Compound Name',\n                              concentration_col='Compound Conc',\n                              response_col='% Inhibition Avg',\n                              plot_title='1 Row Example',\n                              column_num=4,\n                              figsize=(15,4))\n\n\n\n\nFinally, A specific point on the curve can be highlighted using the box or the hline/vline arguments. The box will be plotted for each curve. The figures can be further modified to add a title, adjust the line colors similarly to the examples seen above.\n\nfigure = data.grid_curve_plot(name_col='Compound Name',\n                              concentration_col='Compound Conc',\n                              response_col='% Inhibition Avg',\n                              plot_title='Grid Example',\n                              line_color=rainbow,\n                              box=True,\n                              box_color='#E0115F',\n                              figsize=(8,7))"
  },
  {
    "objectID": "posts/7-py50-additional-features.html#conclusion",
    "href": "posts/7-py50-additional-features.html#conclusion",
    "title": "py50 - Showing off Color Features",
    "section": "Conclusion",
    "text": "Conclusion\nThese are some of the features with the plots generated from py50.\nThis is a great project for me personally and I learned a lot of making py50. I plan to maintain py50 for the foreseeable future. There are a couple of feature ideas swimming in my head that I would love to include in future releases.\nFinally, for anyone who is not as well versed in code, there is a web application version of py50 (click here). The updates for the program takes a little more time, as I tend to tinker a bit more with UI stuff. But overall, it works fairly well and will get you the calculations and plots needed.\nIf you find any issues with py50, feel free to leave a comment on the GitHub repository."
  },
  {
    "objectID": "posts/12-Learning Git.html",
    "href": "posts/12-Learning Git.html",
    "title": "Learning Git",
    "section": "",
    "text": "It has been a good while since I last posted. Time has gotten away from me. Thankfully, I can also fall back on the ‚ÄúI‚Äôve been busy‚Äù shtick. I‚Äôll lean on that. A quick glance on my GitHub profile shows that I have been ‚Äúfairly‚Äù busy. So my ‚Äúexcuse‚Äù isn‚Äôt far off.\n\n\nSince my last post, I have hit a lot of personal milestones. I‚Äôve become a little more comfortable with coding. As someone who is self-taught, it feels like a huge accomplishment to be able to say that. However, there is always more to learn, to improve, and skills to develop. One of the most important ones is Version Control.\nFor those in academia, GitHub is the repository host of choice. Though, I think Codeberg is a good one too and I have begun mirroring many of my projects. Hopefully I can wean myself from Github in the future, since the projects on GitHub is used to train Microsoft‚Äôs Copilot, and potentially exposing private GitHub repositories. Codeberg, as far as I know, cannot be used to train LLMs.\nAll of that is for another post or venue. For now, I wanted to share how I use Git and some basic commands I use.\n\n\n\nAs my projects have become bigger and ambitious, it has become vital to record and track the changes to my code. This is a natural progression for any developer.\nI started writing my projects in Jupyter Notebooks. I love the ability to write in distinct code blocks and to immediately get results printed on script. It helps that each code block can be run out of order, which allows testing and learning of code or custom API. Importantly, with the mix of code and markdown blocks, Jupyter Notebooks are great ways to communicate, share, and teach others your code.\nMy original interaction with Jupyter Notebooks was through the traditional portal - the localhost connection. It was simple and easy.\nAs I got comfortable with simple command scripts, I began making more complicated functions, which requires better organization skills. On the advice of a friend, I began using Integrated Development Environment (IDE)s. There are plenty out there, like VSCode and Spyder. But I gravitated toward the JetBrains software suite - particularly PyCharm and IntelliJ IDEA.\nI like the JetBrains software because of the look of the interface and the ability to customize how it looks. I am an insane person and will change my IDE theme each day depending on my mood. Everyone is different, so play around with each one and find one that you like.\nA main advantage with PyCharm is its integration with Git. It is there from the get go and ready for set up. Plugin with your GitHub account and users are ready to commit, push, or pull their projects. The GUI made it easy peasy! My workflow became:\n\nCreate repository on GitHub\nClone repository through PyCharm onto my machine\nCode\nCommit/Push/Pull as needed\n\nIt was simple and I got comfortable with that for a long time.\nHowever, PyCharm is mainly ‚Äúconnected‚Äù to GitHub. As I begin to transition/mirror projects to Codeberg, I found that the GUI becomes unfriendly and clunky. That has caused me to learn a few command line codes that I found useful.\n\n\n\nThese command line tools are easy ways to connect a project to Git protocols. Importantly, they do not need a specific IDE to be used. All you need is a terminal/command line interface. It is a step up in my coding abilities!\nMy main machine is a MacOS. Thus, these commands are used in the Terminal. Depending on your machine, you should be able to copy/paste these commands to get things working too.\nCheck if git is installed:\ngit --version\nInitialize Git in project folder:\ngit init\nConfirm git tracking:\ngit status\nIf a git repository is made on your GitHub/Codeberg account:\ngit remote add origin https://github.com/your-username/repo.git\nIf you want to add multiple repositories/remotes to your project or want to check which ones are connected to your project:\ngit remote -v\nIf you want to rename your remotes:\ngit remote rename original_name new_name\nStage all changes in project:\ngit add .\nor if you want to stage specific files:\ngit add name_of_file\nCommit changes:\ngit commit -m \"message\"\nPush to repository (first time):\ngit push u- origin main\nPush to repository (subsequent times)\ngit push\nPull changes:\ngit pull\nThose are the main commands that I have learned to use. There are a ton of others that may come in handy to users. I found a nice cheatsheet here. For my main uses though, I still have the GUI to use. If things break, I hope I can figure things out in the future!"
  },
  {
    "objectID": "posts/12-Learning Git.html#learning",
    "href": "posts/12-Learning Git.html#learning",
    "title": "Learning Git",
    "section": "",
    "text": "It has been a good while since I last posted. Time has gotten away from me. Thankfully, I can also fall back on the ‚ÄúI‚Äôve been busy‚Äù shtick. I‚Äôll lean on that. A quick glance on my GitHub profile shows that I have been ‚Äúfairly‚Äù busy. So my ‚Äúexcuse‚Äù isn‚Äôt far off.\n\n\nSince my last post, I have hit a lot of personal milestones. I‚Äôve become a little more comfortable with coding. As someone who is self-taught, it feels like a huge accomplishment to be able to say that. However, there is always more to learn, to improve, and skills to develop. One of the most important ones is Version Control.\nFor those in academia, GitHub is the repository host of choice. Though, I think Codeberg is a good one too and I have begun mirroring many of my projects. Hopefully I can wean myself from Github in the future, since the projects on GitHub is used to train Microsoft‚Äôs Copilot, and potentially exposing private GitHub repositories. Codeberg, as far as I know, cannot be used to train LLMs.\nAll of that is for another post or venue. For now, I wanted to share how I use Git and some basic commands I use.\n\n\n\nAs my projects have become bigger and ambitious, it has become vital to record and track the changes to my code. This is a natural progression for any developer.\nI started writing my projects in Jupyter Notebooks. I love the ability to write in distinct code blocks and to immediately get results printed on script. It helps that each code block can be run out of order, which allows testing and learning of code or custom API. Importantly, with the mix of code and markdown blocks, Jupyter Notebooks are great ways to communicate, share, and teach others your code.\nMy original interaction with Jupyter Notebooks was through the traditional portal - the localhost connection. It was simple and easy.\nAs I got comfortable with simple command scripts, I began making more complicated functions, which requires better organization skills. On the advice of a friend, I began using Integrated Development Environment (IDE)s. There are plenty out there, like VSCode and Spyder. But I gravitated toward the JetBrains software suite - particularly PyCharm and IntelliJ IDEA.\nI like the JetBrains software because of the look of the interface and the ability to customize how it looks. I am an insane person and will change my IDE theme each day depending on my mood. Everyone is different, so play around with each one and find one that you like.\nA main advantage with PyCharm is its integration with Git. It is there from the get go and ready for set up. Plugin with your GitHub account and users are ready to commit, push, or pull their projects. The GUI made it easy peasy! My workflow became:\n\nCreate repository on GitHub\nClone repository through PyCharm onto my machine\nCode\nCommit/Push/Pull as needed\n\nIt was simple and I got comfortable with that for a long time.\nHowever, PyCharm is mainly ‚Äúconnected‚Äù to GitHub. As I begin to transition/mirror projects to Codeberg, I found that the GUI becomes unfriendly and clunky. That has caused me to learn a few command line codes that I found useful.\n\n\n\nThese command line tools are easy ways to connect a project to Git protocols. Importantly, they do not need a specific IDE to be used. All you need is a terminal/command line interface. It is a step up in my coding abilities!\nMy main machine is a MacOS. Thus, these commands are used in the Terminal. Depending on your machine, you should be able to copy/paste these commands to get things working too.\nCheck if git is installed:\ngit --version\nInitialize Git in project folder:\ngit init\nConfirm git tracking:\ngit status\nIf a git repository is made on your GitHub/Codeberg account:\ngit remote add origin https://github.com/your-username/repo.git\nIf you want to add multiple repositories/remotes to your project or want to check which ones are connected to your project:\ngit remote -v\nIf you want to rename your remotes:\ngit remote rename original_name new_name\nStage all changes in project:\ngit add .\nor if you want to stage specific files:\ngit add name_of_file\nCommit changes:\ngit commit -m \"message\"\nPush to repository (first time):\ngit push u- origin main\nPush to repository (subsequent times)\ngit push\nPull changes:\ngit pull\nThose are the main commands that I have learned to use. There are a ton of others that may come in handy to users. I found a nice cheatsheet here. For my main uses though, I still have the GUI to use. If things break, I hope I can figure things out in the future!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Github\n  \n\n      \nHi! üëã\nMy name is Tony and I write this blog. I am currently in a Ph.D.¬†program for drug discovery in Taiwan. Why Taiwan? Well, a series of life choices fresh from university led me there, but I did not start the program until late. I am, what you would call, a late bloomer. And still learning!\nI will treat this as a place to practice code and share my thinking and thought processes.\nYou can find the repository for this site here.\nAny posts with code on this site will be packaged in a Jupyter Notebook and can be found here\nThanks for visiting!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practice in Code",
    "section": "",
    "text": "ü´£ Welcome to a blog on coding, cheminformatics, or other thoughts swimming in my head.üí≠\n\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nAnnouncing the pharmacophore-toolkit!\n\n\nWhere I Generate Simple Pharmacophore Models\n\n\n\n\n\n\nJul 23, 2025\n\n\nTony E. Lin\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\nLearning Git\n\n\nWhere I Learn Version Control\n\n\n\n\n\n\nJun 25, 2025\n\n\nTony E. Lin\n\n\n4 min\n\n\n\n\n\n\n  \n\n\n\n\nDrawing Molecules with Datamol\n\n\nDrawing RDKit molecules easier\n\n\n\n\n\n\nMar 28, 2024\n\n\nTony E. Lin\n\n\n4 min\n\n\n\n\n\n\n  \n\n\n\n\nDrawing Molecules\n\n\nWhere we talk basics\n\n\n\n\n\n\nFeb 27, 2024\n\n\nTony E. Lin\n\n\n4 min\n\n\n\n\n\n\n  \n\n\n\n\nIC50 or pIC50?\n\n\nWhere we talk about scaling\n\n\n\n\n\n\nJan 18, 2024\n\n\nTony E. Lin\n\n\n6 min\n\n\n\n\n\n\n  \n\n\n\n\npy50: Relative or Absolute IC50? ü§î\n\n\nWhere I try to explain things I have read\n\n\n\n\n\n\nJan 16, 2024\n\n\nTony E. Lin\n\n\n9 min\n\n\n\n\n\n\n  \n\n\n\n\npy50 - Showing off Color Features\n\n\nWhere I add personality to figures\n\n\n\n\n\n\nJan 11, 2024\n\n\nTony E. Lin\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\npy50 - Now with Updates!\n\n\n\n\n\n\n\n\n\nJan 9, 2024\n\n\nTony E. Lin\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\nEgg On My Face\n\n\nWhere I scramble to fix my program\n\n\n\n\n\n\nDec 20, 2023\n\n\nTony E. Lin\n\n\n2 min\n\n\n\n\n\n\n  \n\n\n\n\npy50: Single Curve Plot\n\n\n\n\n\n\n\n\n\nDec 7, 2023\n\n\nTony E. Lin\n\n\n5 min\n\n\n\n\n\n\n  \n\n\n\n\nAnnouncing py50!\n\n\n\n\n\n\n\n\n\nDec 5, 2023\n\n\nTony E. Lin\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nHello World - Now With Goals!\n\n\n\n\n\n\n\n\n\nDec 2, 2023\n\n\nTony E. Lin\n\n\n3 min\n\n\n\n\n\n\n  \n\n\n\n\nHello World!\n\n\n\n\n\n\n\n\n\nNov 29, 2023\n\n\nTony E. Lin\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/4-py50-single-plot.html",
    "href": "posts/4-py50-single-plot.html",
    "title": "py50: Single Curve Plot",
    "section": "",
    "text": "Generate Single Dose-Response Curve\nThe following will demo how to calculate the IC50 for a given drug response and generate single dose-response curve.\nThis tutorial will use dummy data found under the ‚Äò../dataset‚Äô folder. The calculation requires inputs from a DataFrame. As shown, only specific information is needed to run the calculations. Finally, the information will be plotted on a sigmoidal curve.\nFor those interested, this notebook can be found here\nAnd if you are not well versed in python code, good news! I have converted this python app into a web application. You can access it here\nNote - December 11 Edit: I shared my package with my classmates and coworkers. All seemed well until someone tried to make a fancy negative sigmoidal curve (from 100% to 0%). I tested my code on my own dataset which has a positive sigmoidal curve (from 0% to 100%). As such, I had to spend time fixing things. It has come out and the next post will address these issues.\n\nExample start\nFirst import the modules and the dataset.\n\nimport pandas as pd\nfrom py50.calculate import Calculate\nfrom py50.plotcurve import PlotCurve\n\n\ndf = pd.read_csv('datasets/py50/single_example.csv')\ndf.head()\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nDrug 1\n100000.0\n90\n94\n92\n\n\n1\nDrug 1\n33300.0\n97\n89\n93\n\n\n2\nDrug 1\n11100.0\n86\n89\n88\n\n\n3\nDrug 1\n3700.0\n81\n88\n84\n\n\n4\nDrug 1\n1240.0\n63\n70\n67\n\n\n\n\n\n\n\n\n\nCalculate IC50\nThe example dataframe will need to be converted into an instance of the Calculate class. Once converted, the table can also be printed for viewing and checking.\n\ndata = Calculate(df)\ndata.show().head()\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nDrug 1\n100000.0\n90\n94\n92\n\n\n1\nDrug 1\n33300.0\n97\n89\n93\n\n\n2\nDrug 1\n11100.0\n86\n89\n88\n\n\n3\nDrug 1\n3700.0\n81\n88\n84\n\n\n4\nDrug 1\n1240.0\n63\n70\n67\n\n\n\n\n\n\n\nCurrently, the py50 program requires the at least 3 columns as input. The rest of the columns will be ignored. py50 requires a column containing the following: - Drug Name - Concentration - Average Response\nNote that py50 requires the average response. Though if you would like to calculate IC50 for one trial of a drug, that is possible.\nThe names for the corresponding columns can be passed in the ‚Äúcalculate_ic50()‚Äù function as follows:\n\nic50 = data.calculate_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\nic50\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nic50 (nM)\nhill_slope\n\n\n\n\n0\nDrug 1\n92.854428\n-7.640263\n439.823988\n1.040875\n\n\n\n\n\n\n\nWhere the maximum and minimum corresponds to the maximum and minimum response. The Hill slope is the hill coefficient. This table can be output as a separate .csv file. For this tutorial, we will output the final table as a markdown table.\nNOTE: The calculation in this table is the Relative IC50 value. A future post will tackle Relative vs Absolute IC50.\n\n\nPlotting\npy50 contains functions that will allow plotting. Let‚Äôs generate a sigmoidal curve from the dataset. This time the dataframe will need to be instantiated into the PlotCurve class. From there, the dataset will be calculated and the resulting information will be ploted on a graph.\n\nplot_data = PlotCurve(df)\n# The input dataset can be inspected as follows:\ndata.show().head()\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nDrug 1\n100000.0\n90\n94\n92\n\n\n1\nDrug 1\n33300.0\n97\n89\n93\n\n\n2\nDrug 1\n11100.0\n86\n89\n88\n\n\n3\nDrug 1\n3700.0\n81\n88\n84\n\n\n4\nDrug 1\n1240.0\n63\n70\n67\n\n\n\n\n\n\n\nFor this example, plotting the dose-response curve uses the single_curve_plot() function. By default, py50 will assume drug concentrations are in nanomolar (nM) concentration and will convert them into micromolar (¬µM) concentrations. This will also mean that the final scale on the x-axis will be in ¬µM. As the dosages for a typical test vary greatly in concentrations, the scale of the concentration will be in log format by default. However, depending on user needs, these can be changed.\nAdditional parameters and their explanation can be found here.\nFirst. Here we will call the ‚Äúsingle_curve_plot‚Äù method with the associated parameters:\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='Default Plot',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (¬µM)',\n                                     ylabel='Inhibition %',\n                                     legend=True,\n                                     output_filename=None)\n\nConcentration on X-axis converted to ¬µM\n\n\n\n\n\n\n\nCustomize figure\nThe above figure looks great! But what if I do not like black for the line color? I would much prefer Teal (#008080). Good news! There are several ways to adjust the graph to highlight the information you want to convey. For colors, we will start with the ‚Äúline_color=‚Äù parameter. The line color can be a specific color name (i.e.¬†red, blue, green, etc) or a hex code. Here is an example of a colored line in ‚Äúteal‚Äù (#008080)\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='Plot with Colored Lines',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (¬µM)',\n                                     ylabel='Inhibition %',\n                                     line_color='#008080',\n                                     legend=True,\n                                     output_filename=None)\n\nConcentration on X-axis converted to ¬µM\n\n\n\n\n\nThat doesn‚Äôt look half bad! But what if you want to highlight the IC50 value? That would give people a quick way to identify where the IC50 lies on the curve. That can be achieved using the ‚Äúbox=‚Äù parameter. The box argument is a boolean argument and by default it will draw a box at the 50% response with respect to the curve.\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='Plot with Colored Lines',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (¬µM)',\n                                     ylabel='Inhibition %',\n                                     line_color='#008080',\n                                     box=True,\n                                     legend=True,\n                                     output_filename=None)\n\nConcentration on X-axis converted to ¬µM\n\n\n\n\n\nThe box highlight can be further modified for color and specific response position you may be interested in. For example, what if you want the box to be red and also highlight IC\\(_{60}\\) or IC\\(_{90}\\)? This can be achieved by using the ‚Äúbox_intercept=‚Äù and ‚Äúbox_color=‚Äù parameters\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='Plot with More Colors!',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (¬µM)',\n                                     ylabel='Inhibition %',\n                                     line_color='#008080',\n                                     box=True,\n                                     box_intercept=60,\n                                     box_color='red',\n                                     legend=True,\n                                     output_filename=None)\n\nConcentration on X-axis converted to ¬µM\n\n\n\n\n\nFinally, the x-axis can be further adjusted.\nThe scale can be changed from log to linear using the ‚Äúxscale=‚Äù argument, changing the shape of the curve from sigmoid to a normal curve. The units of the scale can be changed to nM using the ‚Äúxscale_unit=‚Äù argument. Currently only ¬µM and nM is used.\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='A Linear Plot',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (nM)',\n                                     ylabel='Inhibition %',\n                                     line_color='#008080',\n                                     box=False,\n                                     legend=True,\n                                     xscale='linear',\n                                     xscale_unit='nM',\n                                     xscale_ticks=(-2.5, 10),\n                                     output_filename=None)\n\nConcentration on X-axis is in nM\nnM with ticks constraints!\n\n\n\n\n\nFor this dataset, the ‚Äúxscale=‚Äòlinear‚Äô‚Äù does not look as good.\nAlso notice how on the linear plot the xscale_ticks was also adjusted to fit the concentration in nM scale. This was achieved using the ‚Äúxscale_ticks=‚Äù argument. Note that the xscale_ticks will affect how the line curve is drawn and should be adjusted to fit the dataset on the plot. Notice how the plot below has the xscale_ticks ranging from 0 to 2 and how it would affect the resulting curve line.\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='X-Axis is Set to nM',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (nM)',\n                                     ylabel='Inhibition %',\n                                     line_color='#008080',\n                                     box=True,\n                                     box_color='orange',\n                                     legend=True,\n                                     xscale='log',\n                                     xscale_unit='nM',\n                                     xscale_ticks=(0, 2),\n                                     output_filename=None)\n\nConcentration on X-axis is in nM\nnM with ticks constraints!\n\n\n\n\n\n\n\nSaving the figure\nFinally, the figure can be saved using the ‚Äúoutput_filename=‚Äù argument. Change ‚ÄúNone‚Äù to file path of choice. Images should be saved in .png format.\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='X-Axis is Set to nM',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (nM)',\n                                     ylabel='Inhibition %',\n                                     line_color='#008080',\n                                     box=True,\n                                     box_color='orange',\n                                     legend=True,\n                                     xscale='log',\n                                     xscale_unit='¬µM',\n                                     xscale_ticks=(-2.5, 2.5),\n                                     output_filename=None)\n\nConcentration on X-axis converted to ¬µM\n¬µM with ticks constraints!\n\n\n\n\n\nAdditionally, the figure can also be saved as follows:\n\nfigure.savefig('tutorial_figure_001.png')\n\nAnd that should be it!\nThis is my first ‚Äúbig‚Äù python project and I learned a lot from it. I know I should clean up the code in the future, but for now, I‚Äôm glad to have it up and running! I plan on maintaining this for the foreseeable future. I hope it helps others as much as it has helped me!"
  },
  {
    "objectID": "posts/1-hello-world.html",
    "href": "posts/1-hello-world.html",
    "title": "Hello World!",
    "section": "",
    "text": "Hello World!"
  },
  {
    "objectID": "posts/5-egg-on-my-face.html",
    "href": "posts/5-egg-on-my-face.html",
    "title": "Egg On My Face",
    "section": "",
    "text": "Well I have egg on my face. Rotten eggs, so that they are unsalvageable to be used in scrambled eggs.\nHere is the story. In my earlier post I announced and in the last post I gave an example on how to use the program in python. Everything worked! The thing is, it worked for my datasets. When I shared this code/program with my co-workers/labmates, my program quickly crumbled like a dusty cracker. It is a good thing that I placed it as version 0.1.0. I am currently in the process of fixing the bugs and I hope to finish it sometime in the new year (Hey, a New Year‚Äôs resolution I might actually finish for once!).\nI will be sure to give updates and tutorials on the program once I finish.\nIf you would like to use the program now, I push out updates faster to the Streamlit version of py50 (see here). This web application is for my co-workers/labmates, but I hope others are able to find it and find it useful too.\nIn the meantime, I‚Äôll be working on fixing these bugs and refactoring the code so that it will be a little bit easier to fix in the future (you‚Äôre welcome future me).\nThanks!"
  },
  {
    "objectID": "posts/6-py50-QuickStart.html",
    "href": "posts/6-py50-QuickStart.html",
    "title": "py50 - Now with Updates!",
    "section": "",
    "text": "It is a new year. That means we can start fresh. No need to look at the past entries when I was starting the blog ü´£.\nI have tested py50 and fixed the bugs previously found, while also adding some, hopefully, quality of life enhancements. Teh quality of life enhancements are mostly for me, as I have refactored a lot of the code to make future maintenance easier. I can reduce the code further, but for now, I like what I have. For the user, the quality of life enhancements are more prevalent with the py50 Streamlit Web Application (link here) and include things like grammar, UI consistency, and information to inform the user of what units the data is in or the type of calculations made. These updates, while important for user experience, are more involved and should be rolling out at the end of the month.\nIn contrast, the py50 python module is good to go and I am ready to introduce them. This post is adapted from the Quickstart Tutorial, only with a little more of my personal flair - A lot more fun for me to write, but (hopefully) not annoying for readers.\nHere I will introduce (as of this writing) py50 v0.3.2."
  },
  {
    "objectID": "posts/6-py50-QuickStart.html#py50-introduction",
    "href": "posts/6-py50-QuickStart.html#py50-introduction",
    "title": "py50 - Now with Updates!",
    "section": "",
    "text": "It is a new year. That means we can start fresh. No need to look at the past entries when I was starting the blog ü´£.\nI have tested py50 and fixed the bugs previously found, while also adding some, hopefully, quality of life enhancements. Teh quality of life enhancements are mostly for me, as I have refactored a lot of the code to make future maintenance easier. I can reduce the code further, but for now, I like what I have. For the user, the quality of life enhancements are more prevalent with the py50 Streamlit Web Application (link here) and include things like grammar, UI consistency, and information to inform the user of what units the data is in or the type of calculations made. These updates, while important for user experience, are more involved and should be rolling out at the end of the month.\nIn contrast, the py50 python module is good to go and I am ready to introduce them. This post is adapted from the Quickstart Tutorial, only with a little more of my personal flair - A lot more fun for me to write, but (hopefully) not annoying for readers.\nHere I will introduce (as of this writing) py50 v0.3.2."
  },
  {
    "objectID": "posts/6-py50-QuickStart.html#how-does-py50-work",
    "href": "posts/6-py50-QuickStart.html#how-does-py50-work",
    "title": "py50 - Now with Updates!",
    "section": "How does py50 work?",
    "text": "How does py50 work?\nThere are software available to calculate IC50. GraphPad is a popular choice. There is also an online IC50 Calculator by AAT Bioquest. These can be great choices, but not particularly ones that fit users who want to automate everything through code.\nThat is where py50 comes in. py50 can work directly with a pandas DataFrame. This makes it easy to quickly modify the data into a favorable format by the user before graphing. Currently, there are three submodules associated with py50. Here we will import all of them.\n\nimport pandas as pd\nfrom py50.calculator import Calculator\nfrom py50.plotcurve import PlotCurve\nfrom py50.plot_settings import CBMARKERS, CBPALETTE"
  },
  {
    "objectID": "posts/6-py50-QuickStart.html#calculate-relative-and-absolute-ic50",
    "href": "posts/6-py50-QuickStart.html#calculate-relative-and-absolute-ic50",
    "title": "py50 - Now with Updates!",
    "section": "Calculate Relative and Absolute IC50",
    "text": "Calculate Relative and Absolute IC50\nFirst we will calculate Relative and Absolute IC50. A future post will dive deeper into the differences between the two. For now, we are concerned with calculating them. py50 uses the Four Paramater Logistic (4PL) Regression algorithm to calculate the IC50: \\[Y = \\text{Min} + \\frac{\\text{Max} - \\text{Min}}{1 + \\left(\\frac{X}{\\text{IC50}}\\right)^{\\text{Hill coefficient}}}\\] where min is the minimum response value, max is the maximum response value, Y is the response values of the curves, and X is the concentration.\n\n# Read in dataset\nexample = pd.read_csv('datasets/py50/single_example.csv')\n\ncalc_data = Calculator(example) # Instantiate dataframe into the Calculator class \ncalc_data.show().head()\n\n\n\n\n\n\n\n\nCompound Name\nCompound Conc\n% Inhibition 1\n% Inhibition 2\n% Inhibition Avg\n\n\n\n\n0\nDrug 1\n100000.0\n90\n94\n92\n\n\n1\nDrug 1\n33300.0\n97\n89\n93\n\n\n2\nDrug 1\n11100.0\n86\n89\n88\n\n\n3\nDrug 1\n3700.0\n81\n88\n84\n\n\n4\nDrug 1\n1240.0\n63\n70\n67\n\n\n\n\n\n\n\nOnce we have the data loaded, the calculations can be performed. If only relative IC50 is needed, users cna call the calc_data.calculate_ic50() function instead. Both functions work the same and need three columns to function properly - name of the column, concentration column, and the response column.\n\ncalculation = calc_data.calculate_absolute_ic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\ncalculation\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\n\n\n\n\n0\nDrug 1\n92.854428\n-7.640263\n439.823988\n584.734114\n1.040875\n\n\n\n\n\n\n\nIf IC50 is not your cup of tea, you can quickly scale the values into pIC50 values. This is done using the calculate_pic50() function. This will calculate absolute IC50, but will append two additional columns for the relative pIC50 and absolute pIC50, respectively.\n\ncalculation = calc_data.calculate_pic50(name_col='Compound Name', concentration_col='Compound Conc', response_col='% Inhibition Avg')\ncalculation\n\n\n\n\n\n\n\n\ncompound_name\nmaximum\nminimum\nrelative ic50 (nM)\nabsolute ic50 (nM)\nhill_slope\nrelative pIC50\nabsolute pIC50\n\n\n\n\n0\nDrug 1\n92.854428\n-7.640263\n439.823988\n584.734114\n1.040875\n6.356721\n6.233042"
  },
  {
    "objectID": "posts/6-py50-QuickStart.html#single-curve",
    "href": "posts/6-py50-QuickStart.html#single-curve",
    "title": "py50 - Now with Updates!",
    "section": "Single Curve",
    "text": "Single Curve\nOkay, so the calculations are all well and good, but what if I want to have my data represented a graph? Godo news! py50 is able to handle this with ease. There are three different types of plots that can be generated. Here we will start with the classic single dose-response curve.\nThis can be done by using hte single_curve_plot() function. As for the parameters, I personally prefer lots of options. I like to be able to tweak my images to my liking. It is my goal to give these same options to other users. All three types of plots have a lot of arguments, which while daunting, I think can generate a figure that really fits the user‚Äôs personality and use case. These can be found in the documentation page here.\n\nsingle = pd.read_csv('datasets/py50/single_example.csv')\nplot_data = PlotCurve(single)\n\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='Default Plot Single Example (Positive)',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (nM)',\n                                     ylabel='Inhibition %',\n                                     legend=True,\n                                     # Sometimes the legend needs to be manually adjusted and can be with the legend_loc argument\n                                     legend_loc='lower right')\n\n\n\n\nThe graphing works great for both positive and negative curves (The older versions of py50 had issues handling this. I forgot the carry the one. Oops!).\n\nsingle_negative = pd.read_csv('datasets/py50/single_example_negative.csv')\nplot_data = PlotCurve(single_negative)\nfigure = plot_data.single_curve_plot(concentration_col='Compound Conc',\n                                     response_col='% Inhibition Avg',\n                                     plot_title='Default Plot Single Example (Negative Slope)',\n                                     drug_name='Drug 1',\n                                     xlabel='Logarithmic Concentration (nM)',\n                                     ylabel='Inhibition %',\n                                     legend=True)"
  },
  {
    "objectID": "posts/6-py50-QuickStart.html#multi-curve",
    "href": "posts/6-py50-QuickStart.html#multi-curve",
    "title": "py50 - Now with Updates!",
    "section": "Multi-Curve",
    "text": "Multi-Curve\nThose graphs look good! But what if you are working with more than one drug? True, we can loop over each drug and generate single curve plots for each one. But there are times that combining the curves onto a single plot would be more descriptive of our data or story. The other two options allow just that! First we will go through the multi-curve plot.\nThe multi_curve_plot() function works in much the same way as the single_curve_plot() above. The main difference is that multi_curve_plot will inherently scan the name_col for unique names and generate the plot accordingly. By default, the CBPALETTE and CBMARKERS, can handle up to eight items. I do not think that should be an issue since, with the four curves in the example, it looks busy already. But more is an option if needed.\n\n# Read in Dataset\nmulti = pd.read_csv('datasets/py50/multiple_example.csv')\n\n# Instantiate dataframe into the PlotCurve class \nplot_data = PlotCurve(multi)\n\n# Optional to inspect table\nplot_data.show()\n\n# Generate figure\nfigure = plot_data.multi_curve_plot(name_col='Compound Name',\n                                    concentration_col='Compound Conc',\n                                    response_col='% Inhibition Avg',\n                                    plot_title='Multi-Curve Plot',\n                                    xlabel='Logarithmic Concentration (nM)',\n                                    ylabel='Inhibition %',\n                                    legend=True,\n                                    line_color=CBPALETTE,\n                                    marker=CBMARKERS,\n                                    # To adjust Y-Axis, can use ymax or ymin arguments\n                                    ymin=-10)\n\n\n\n\nAgain, the functions will work for both positive and negative curves!\n\n# For negative slope\n# Read in Dataset\nmulti = pd.read_csv('datasets/py50/multiple_example_negative.csv')\n\n# Instantiate dataframe into the PlotCurve class \nplot_data = PlotCurve(multi)\n\nfigure = plot_data.multi_curve_plot(name_col='Compound Name',\n                                    concentration_col='Compound Conc',\n                                    response_col='% Inhibition Avg',\n                                    plot_title='Multi-Curve Plot (Negative Slope)',\n                                    xlabel='Logarithmic Concentration (nM)',\n                                    ylabel='Inhibition %',\n                                    legend=True,\n                                    line_color=CBPALETTE,\n                                    marker=CBMARKERS,\n                                    ymin=-10)"
  },
  {
    "objectID": "posts/6-py50-QuickStart.html#grid-plot",
    "href": "posts/6-py50-QuickStart.html#grid-plot",
    "title": "py50 - Now with Updates!",
    "section": "Grid Plot",
    "text": "Grid Plot\nFinally, there is the grid_plot() function. This works very much the same as the multi_curve_plot() above, except each curve will be drawn as a single plot arrayed in a grid. This is good if you already have a particular layout, but want to draw multiple curves. The function works very similarly to the other two functions above.\n\n# Read in Dataset\ngrid = pd.read_csv('datasets/py50/multiple_example_negative.csv')\n\n# Instantiate dataframe into the PlotCurve class \ngrid_plot = PlotCurve(grid)\n\n# Optional to inspect table\n# grid_plot.show()\n\nfigure = grid_plot.grid_curve_plot(name_col='Compound Name',\n                                   concentration_col='Compound Conc',\n                                   response_col='% Inhibition Avg',\n                                   plot_title='Multi-Curve Plot',\n                                   xlabel=('Logarithmic Concentration (nM)'),\n                                   ylabel='Inhibition %',\n                                   conc_unit='nM',\n                                   # adjusting the figsize() may be needed for columns bigger than 1 by 2\n                                   figsize=(8,8))"
  },
  {
    "objectID": "posts/6-py50-QuickStart.html#conclusion",
    "href": "posts/6-py50-QuickStart.html#conclusion",
    "title": "py50 - Now with Updates!",
    "section": "Conclusion",
    "text": "Conclusion\nThat is it!\nThis is my first very big (in my eyes) python project and I learned a lot. Hopefully the pacakge can help others too.\nAnd for anyone reading this who are not code savvy, I have converted py50 into a web application using streamlit. It can be found here. The update may be a little bit slower, as managing UI takes a bit more time, but hopefully this makes py50 more accessible to people.\nThanks for reading. üôå"
  },
  {
    "objectID": "posts/3-announcing-py50.html",
    "href": "posts/3-announcing-py50.html",
    "title": "Announcing py50!",
    "section": "",
    "text": "py50: Generate Dose-Response Curves\nI would like to announce a new project I have been working on: py50: Generate Dose-Response Curves. It is the first ‚Äúbig‚Äù python project that I have worked on. This package will calculate IC50 (py50, get it? ‚Ä¶ Anyone?) and will plot the dose-response curves. And for anyone who does not know how to code, I created a Streamlit web application(click here). I hope others will be able to find this useful for their own work.\n\nWhy did I make py50?\nWell, this was mostly for myself. I am lucky to be in a lab that has close collaborations with other labs, meaning that my work can quickly be shared with experts in other areas. They will generate the dose-response curves for me. But sometimes when I organize my figures, I realized that the curves do not fit my style. The color does not match my docking pose, or my protein, or the font could be bigger, etc. Now, I could ask them to change it, but I do not like to be a burden on people. They spent a lot of time doing this work, the least I could do is learn the program they used to generate plot, right?\nWell, the truth is I hate using their program (which I will not name here)!\nSo I went about creating my own. As a python module, it can be customizable to anyone‚Äôs workflow. The outcome is perfect for me. After I showed this to my advisor, he made the comment that it would be good for others to use. And I realized that I could easily convert the code for this purpose.\nFor py50, I have a KNIME workflow. That is available upon request. It is not as elegant, as they are not custom KNIME nodes, so I am a little more reserved in sharing that workflow. Another issue with KNIME is that it would require the user to have python installed on their machine. I realized that could be a hassle. So I also created a Streamlit web application. Using Streamlit has been on my list of things to try for a very long time, and I am glad that with my py50 project, I was able to do that.\nThe code is not perfect. There is a lot that I need to clean up on the backend. But for what I have, it works and I learned a lot. I am very surprised I got a decent package up and running. The plan is to maintain this for the foreseeable future. And, if the inspiration is right, I will add some extra features over the coming years.\nThe next few posts will dive into details about py50, the functions, and concepts of IC50 that I ran into."
  },
  {
    "objectID": "posts/2-hello-world-goals.html",
    "href": "posts/2-hello-world-goals.html",
    "title": "Hello World - Now With Goals!",
    "section": "",
    "text": "Hello World - Now with Goals\nHello everyone. My name is Tony. I am currently in a Ph.D.¬†program for drug discovery in Taiwan. Why Taiwan? Well, a series of life choices fresh from university led me there. I did not get a start into my field of study overnight. I am a late bloomer. And still learning. Or at least trying to!\nI specialize in cheminformatics - using computers to sort and categorize molecules. There‚Äôs a lot of good software out there that can help anyone interested into getting into the field. That includes both paid versions, such as Schrodiner‚Äôs Maestro, or open source software such as the wonderful suite available from the University of Hamburg. Those tools are great! But I quickly realized that relying on software, as good as they can be, can be very limiting. What if I have an idea that does not fit the available software? What if I want to make modifications to the figures I make? What if I want to try a new screening protocol? There is only one way to do these things - coding! And learning to code requires a lot of practice.\nI know that with experience. I have tried learning ot code multiple times in my life. Each time I have failed. There is a whole host of reasons. Maybe the language I chose was not for me. Java, is great, but at the time I can barely wrap my head around it. I tried making a small iOS app in the early days of the iPhone, which used UIKit. No dice. When Apple transitioned into Swift UI, I thought ‚ÄúGreat! A new start!‚Äù Only to fail horribly.\nIt was not until I got into the Ph.D.¬†program (and again, I started late!) that I finally tried and‚Ä¶ well I did not succeed, but I got way further than before.\nWhat helped was having a project and actually sticking with it. Well, what really helped is that I found a lot of examples online tackling similar problems I had. People writing about their code, sharing new tools and packages, and how to solve them. All of this helped make things simple enough for me to at least get started.\nFor that, I am forever grateful.\nThat brings me to this blog. I will use it as a place to practice coding, my thinking and thought processes, what I am interested in, and hopefully, as a way to share with others.\nThis will be my way of paying it forward.\nAnd barring that, it will be a good place to showcase my failures to the world. I‚Äôm ok with that too."
  }
]